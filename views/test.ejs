<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Student Exam Portal</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary: #2563eb;
            --primary-light: #3b82f6;
            --primary-dark: #1d4ed8;
            --secondary: #6b7280;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --dark: #111827;
            --light: #f9fafb;
            --white: #ffffff;
            --border: #e5e7eb;
            --border-radius: 0.5rem;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
        }

        body {
            background-color: #f3f4f6;
            color: var(--dark);
            line-height: 1.6;
        }

        /* Header Styles */
        .header {
            background-color: var(--white);
            padding: 1rem 2rem;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .header-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #fff;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .timer-display {
            background-color: var(--white);
            color: var(--dark);
            padding: 0.5rem 1rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .timer-critical {
            animation: pulse-red 2s infinite;
        }

        @keyframes pulse-red {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        /* Main Container Styles */
        .main-container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 1rem;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 2rem;
        }

        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        /* Question Content Styles */
        .question-panel {
            background-color: var(--white);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .question-header {
            background-color: var(--primary);
            color: var(--white);
            padding: 1rem 1.5rem;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .question-badges {
            display: flex;
            gap: 0.5rem;
        }

        .badge {
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-EASY {
            background-color: #bbf7d0;
            color: #166534;
        }

        .badge-MEDIUM {
            background-color: #fef08a;
            color: #854d0e;
        }

        .badge-HARD {
            background-color: #fecaca;
            color: #991b1b;
        }

        .badge-category {
            background-color: #dbeafe;
            color: #1e40af;
        }

        .badge-marks {
            background-color: #e9d5ff;
            color: #6b21a8;
        }

        .question-content {
            padding: 1.5rem;
        }

        .question-title {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: #fff;
        }

        .question-description {
            margin-bottom: 1.5rem;
        }

        .section-title {
            font-size: 1rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-title i {
            color: var(--primary);
        }

        pre {
            background-color: #f8fafc;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 1rem;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin-bottom: 1rem;
        }

        /* MCQ Options Styles */
        .mcq-options {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        .mcq-option {
            background-color: #f8fafc;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
        }

        .mcq-option:hover {
            background-color: #f1f5f9;
            border-color: #d1d5db;
        }

        .mcq-option.selected {
            background-color: #dbeafe;
            border-color: var(--primary);
        }

        .mcq-option input[type="radio"] {
            margin-right: 0.75rem;
            cursor: pointer;
            height: 1.2rem;
            width: 1.2rem;
        }

        .mcq-option label {
            cursor: pointer;
            flex: 1;
        }

        /* Code Editor Styles */
        .editor-section {
            margin-top: 2rem;
            border-top: 1px solid var(--border);
            padding-top: 1.5rem;
        }

        .language-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .language-selector select {
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            background-color: var(--white);
            font-size: 0.9rem;
            cursor: pointer;
        }

        .code-editor {
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            overflow: hidden;
        }

        .code-textarea {
            width: 100%;
            min-height: 300px;
            padding: 1rem;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            border: none;
            resize: vertical;
            background-color: #1e1e1e;
            color: #d4d4d4;
        }

        .editor-buttons {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        /* Button Styles */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: var(--border-radius);
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background-color: var(--primary);
            color: var(--white);
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: var(--white);
            color: var(--secondary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background-color: #f8fafc;
        }

        .btn-success {
            background-color: var(--success);
            color: var(--white);
        }

        .btn-success:hover {
            background-color: #059669;
        }

        .btn-danger {
            background-color: var(--danger);
            color: var(--white);
        }

        .btn-danger:hover {
            background-color: #dc2626;
        }

        .btn-lg {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
        }

        /* Test Results Styles */
        .results-section {
            margin-top: 2rem;
            border-top: 1px solid var(--border);
            padding-top: 1.5rem;
        }

        .result-summary {
            background-color: #f8fafc;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .result-pass {
            color: var(--success);
            font-weight: 600;
        }

        .result-fail {
            color: var(--danger);
            font-weight: 600;
        }

        .test-results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .test-results-table th, 
        .test-results-table td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border);
            text-align: left;
        }

        .test-results-table th {
            background-color: #f8fafc;
            font-weight: 600;
        }

        .test-details-link {
            color: var(--primary);
            cursor: pointer;
            text-decoration: underline;
        }

        .diff-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
            background-color: #f8fafc;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 1rem;
        }

        .diff-expected, 
        .diff-actual {
            padding: 1rem;
            border-radius: 0.25rem;
        }

        .diff-expected {
            background-color: #f0fdf4;
            border: 1px solid #bbf7d0;
        }

        .diff-actual {
            background-color: #fef2f2;
            border: 1px solid #fecaca;
        }

        /* Sidebar Styles */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .sidebar-card {
            background-color: var(--white);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .sidebar-header {
            background-color: var(--primary);
            color: var(--white);
            padding: 0.75rem 1rem;
            font-weight: 600;
        }

        .sidebar-content {
            padding: 1rem;
        }

        /* Navigation Styles */
        .question-navigation {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
        }

        .nav-button {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f8fafc;
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .nav-button:hover {
            background-color: #f1f5f9;
        }

        .nav-button.active {
            background-color: var(--primary);
            color: var(--white);
            border-color: var(--primary);
        }

        .nav-button.unanswered {
            border: 2px solid var(--danger);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }
            70% {
                box-shadow: 0 0 0 5px rgba(239, 68, 68, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        .nav-controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .nav-controls button {
            flex: 1;
        }

        /* Submit Container */
        .submit-container {
            padding: 1rem;
            text-align: center;
        }

        .submit-btn {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--success);
            color: var(--white);
            border: none;
            border-radius: var(--border-radius);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .submit-btn:hover {
            background-color: #059669;
        }

        /* Progress Styles */
        .progress-container {
            margin-top: 0.5rem;
        }

        .progress-bar {
            height: 0.5rem;
            background-color: #e5e7eb;
            border-radius: 9999px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--primary);
            border-radius: 9999px;
            transition: width 0.3s ease;
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            color: var(--secondary);
        }

        /* Custom Test Section */
        .custom-test-section {
            margin-top: 1.5rem;
            border-top: 1px solid var(--border);
            padding-top: 1.5rem;
        }

        .custom-input-textarea {
            width: 100%;
            min-height: 100px;
            padding: 1rem;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            resize: vertical;
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }

        /* Tooltip Styles */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: var(--dark);
            color: var(--white);
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Dark Mode Toggle */
        .dark-mode-toggle {
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            background-color: transparent;
            color: var(--secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .dark-mode-toggle:hover {
            background-color: #f1f5f9;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .header {
                padding: 0.75rem 1rem;
                flex-direction: column;
                gap: 0.5rem;
            }

            .main-container {
                margin: 1rem auto;
                padding: 0 0.75rem;
            }

            .question-header {
                padding: 0.75rem 1rem;
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            .question-content {
                padding: 1rem;
            }

            .diff-view {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <p id="user" hidden><%=user._id%></p>
<p id="exam" hidden><%=exam._id%></p>
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <div class="header-logo">
                <i class="fas fa-graduation-cap"></i> Exam Portal
            </div>
            <div class="header-title" id="examTitle">Loading exam...</div>
        </div>
        <div class="header-right">
            <div class="timer-display" id="examTimer">
                <i class="fas fa-clock"></i> --:--:--
            </div>
            <div class="dark-mode-toggle" id="darkModeToggle">
                <i class="fas fa-moon"></i>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Question Panel -->
        <div class="question-panel">
            <div class="question-header">
                <div class="question-number" id="questionNumber">Question</div>
                <div class="question-badges" id="questionBadges"></div>
            </div>
            <div class="question-content" id="questionContainer">
                <div class="loading-container">
                    <p>Loading question...</p>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Navigation Card -->
            <div class="sidebar-card">
                <div class="sidebar-header">
                    <i class="fas fa-map-marker-alt"></i> Question Navigation
                </div>
                <div class="sidebar-content">
                    <div class="question-navigation" id="questionNavigation"></div>
                    
                    <div class="nav-controls">
                        <button class="btn btn-secondary" id="prevQuestion" disabled>
                            <i class="fas fa-arrow-left"></i> Previous
                        </button>
                        <button class="btn btn-secondary" id="nextQuestion" disabled>
                            Next <i class="fas fa-arrow-right"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Progress Card -->
            <div class="sidebar-card">
                <div class="sidebar-header">
                    <i class="fas fa-tasks"></i> Exam Progress
                </div>
                <div class="sidebar-content">
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-stats">
                            <span id="answeredQuestions">0 answered</span>
                            <span id="totalQuestions">0 total</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Exam Info Card -->
            <div class="sidebar-card">
                <div class="sidebar-header">
                    <i class="fas fa-info-circle"></i> Exam Information
                </div>
                <div class="sidebar-content">
                    <p><strong>Duration:</strong> <span id="examDuration">--</span></p>
                    <p><strong>Type:</strong> <span id="examType">--</span></p>
                    <div class="tooltip">
                        <i class="fas fa-question-circle"></i>
                        <span class="tooltip-text">Questions marked with a red border are unanswered</span>
                    </div>
                </div>
            </div>

            <!-- Submit Card -->
            <div class="sidebar-card">
                <div class="submit-container">
                    <button class="submit-btn" id="submitExam">
                        <i class="fas fa-paper-plane"></i> Submit Exam
                    </button>
                </div>
            </div>
        </div>
    </div>
<script>

    /**
 * Camera Permission Handler for Exam Portal
 * 
 * This script handles camera permission checking and requesting
 * before allowing users to start the exam.
 */

const CameraPermissionHandler = (function() {
    let cameraStream = null;
    let permissionGranted = false;
    
    /**
     * Check if camera permissions are granted
     */
    async function checkCameraPermission() {
        try {
            // First check if navigator.permissions is supported (not available in all browsers)
            if (navigator.permissions && navigator.permissions.query) {
                const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                console.log('Camera permission status:', permissionStatus.state);
                
                if (permissionStatus.state === 'granted') {
                    return await testCameraAccess();
                } else if (permissionStatus.state === 'denied') {
                    return false;
                } else {
                    // Permission is 'prompt' - need to request access
                    return await requestCameraAccess();
                }
            } else {
                // Fallback: Try to access camera directly
                return await testCameraAccess();
            }
        } catch (error) {
            console.error('Error checking camera permission:', error);
            return false;
        }
    }
    
    /**
     * Test camera access by trying to get media stream
     */
    async function testCameraAccess() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 320 },
                    height: { ideal: 240 },
                    facingMode: "user"
                } 
            });
            
            // Stop the stream immediately after testing
            stream.getTracks().forEach(track => track.stop());
            console.log('Camera access test successful');
            return true;
        } catch (error) {
            console.error('Camera access test failed:', error);
            return false;
        }
    }
    
    /**
     * Request camera access from user
     */
    async function requestCameraAccess() {
        try {
            showCameraRequestModal();
            
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 320 },
                    height: { ideal: 240 },
                    facingMode: "user"
                } 
            });
            
            // Store the stream for later use
            cameraStream = stream;
            permissionGranted = true;
            
            hideCameraRequestModal();
            showSuccessMessage('Camera access granted successfully!');
            
            return true;
        } catch (error) {
            console.error('Camera access request failed:', error);
            hideCameraRequestModal();
            
            if (error.name === 'NotAllowedError') {
                showCameraErrorModal('Camera access denied. Please enable camera access in your browser settings and refresh the page.');
            } else if (error.name === 'NotFoundError') {
                showCameraErrorModal('No camera found. Please connect a camera and try again.');
            } else if (error.name === 'NotReadableError') {
                showCameraErrorModal('Camera is being used by another application. Please close other applications and try again.');
            } else {
                showCameraErrorModal('Failed to access camera. Please check your camera settings and try again.');
            }
            
            return false;
        }
    }
    
    /**
     * Show camera request modal
     */
    function showCameraRequestModal() {
        const modal = document.createElement('div');
        modal.id = 'cameraRequestModal';
        modal.className = 'camera-modal-overlay';
        modal.innerHTML = `
            <div class="camera-modal-content">
                <div class="camera-modal-header">
                    <h3><i class="fas fa-video"></i> Camera Access Required</h3>
                </div>
                <div class="camera-modal-body">
                    <p>This exam requires camera access for monitoring purposes.</p>
                    <p>Please allow camera access when prompted by your browser.</p>
                    <div class="camera-loading">
                        <i class="fas fa-spinner fa-spin"></i>
                        <span>Requesting camera access...</span>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    /**
     * Hide camera request modal
     */
    function hideCameraRequestModal() {
        const modal = document.getElementById('cameraRequestModal');
        if (modal) {
            modal.remove();
        }
    }
    
    /**
     * Show camera error modal
     */
    function showCameraErrorModal(message) {
        const modal = document.createElement('div');
        modal.id = 'cameraErrorModal';
        modal.className = 'camera-modal-overlay';
        modal.innerHTML = `
            <div class="camera-modal-content camera-error">
                <div class="camera-modal-header">
                    <h3><i class="fas fa-exclamation-triangle"></i> Camera Access Error</h3>
                </div>
                <div class="camera-modal-body">
                    <p>${message}</p>
                    <div class="camera-instructions">
                        <h4>To enable camera access:</h4>
                        <ul>
                            <li><strong>Chrome/Safari:</strong> Click the camera icon in the address bar</li>
                            <li><strong>Firefox:</strong> Click on the shield icon in the address bar</li>
                            <li><strong>Edge:</strong> Click on the lock icon in the address bar</li>
                        </ul>
                        <p>After enabling camera access, please refresh the page and try again.</p>
                    </div>
                </div>
                <div class="camera-modal-footer">
                    <button id="tryAgainBtn" class="btn btn-primary">
                        <i class="fas fa-redo"></i> Try Again
                    </button>
                    <button id="refreshPageBtn" class="btn btn-secondary">
                        <i class="fas fa-refresh"></i> Refresh Page
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Add event listeners
        document.getElementById('tryAgainBtn').addEventListener('click', async () => {
            modal.remove();
            await initializeCameraCheck();
        });
        
        document.getElementById('refreshPageBtn').addEventListener('click', () => {
            window.location.reload();
        });
    }
    
    /**
     * Show success message
     */
    function showSuccessMessage(message) {
        const notification = document.createElement('div');
        notification.className = 'camera-notification camera-success';
        notification.innerHTML = `
            <div class="notification-content">
                <i class="fas fa-check-circle"></i>
                <span>${message}</span>
            </div>
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.classList.add('show');
        }, 10);
        
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    /**
     * Update start exam button state
     */
    function updateStartExamButton(enabled) {
        const startButton = document.getElementById('startExamButton');
        if (startButton) {
            startButton.disabled = !enabled;
            
            if (enabled) {
                startButton.innerHTML = '<i class="fas fa-play"></i> Start Exam';
                startButton.classList.remove('disabled');
            } else {
                startButton.innerHTML = '<i class="fas fa-video"></i> Camera Access Required';
                startButton.classList.add('disabled');
            }
        }
    }
    
    /**
     * Show camera status in the UI
     */
    function updateCameraStatus(status, message) {
        let statusElement = document.getElementById('cameraStatus');
        
        if (!statusElement) {
            statusElement = document.createElement('div');
            statusElement.id = 'cameraStatus';
            statusElement.className = 'camera-status';
            
            // Insert before the start button
            const startButton = document.getElementById('startExamButton');
            if (startButton && startButton.parentNode) {
                startButton.parentNode.insertBefore(statusElement, startButton);
            }
        }
        
        const iconClass = status === 'success' ? 'fa-check-circle' : 
                         status === 'error' ? 'fa-exclamation-circle' : 'fa-spinner fa-spin';
        
        statusElement.className = `camera-status camera-status-${status}`;
        statusElement.innerHTML = `
            <i class="fas ${iconClass}"></i>
            <span>${message}</span>
        `;
    }
    
    /**
     * Initialize camera permission check
     */
    async function initializeCameraCheck() {
        updateCameraStatus('checking', 'Checking camera access...');
        updateStartExamButton(false);
        
        try {
            const hasPermission = await checkCameraPermission();
            
            if (hasPermission) {
                permissionGranted = true;
                updateCameraStatus('success', 'Camera access granted');
                updateStartExamButton(true);
                return true;
            } else {
                updateCameraStatus('error', 'Camera access required');
                updateStartExamButton(false);
                return false;
            }
        } catch (error) {
            console.error('Error during camera initialization:', error);
            updateCameraStatus('error', 'Camera access error');
            updateStartExamButton(false);
            return false;
        }
    }
    
    /**
     * Get the camera stream (if already granted)
     */
    function getCameraStream() {
        return cameraStream;
    }
    
    /**
     * Check if permission is granted
     */
    function isPermissionGranted() {
        return permissionGranted;
    }
    
    /**
     * Clean up camera resources
     */
    function cleanup() {
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            cameraStream = null;
        }
        permissionGranted = false;
    }
    
    // Return public API
    return {
        initialize: initializeCameraCheck,
        checkPermission: checkCameraPermission,
        requestAccess: requestCameraAccess,
        getCameraStream: getCameraStream,
        isPermissionGranted: isPermissionGranted,
        cleanup: cleanup
    };
})();

// CSS Styles for camera permission modals and notifications
const cameraStyles = `
    .camera-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        animation: fadeIn 0.3s ease;
    }
    
    .camera-modal-content {
        background-color: white;
        border-radius: 8px;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        animation: slideUp 0.3s ease;
    }
    
    .camera-modal-content.camera-error {
        max-width: 600px;
    }
    
    .camera-modal-header {
        padding: 1.5rem;
        border-bottom: 1px solid #e5e7eb;
        background-color: #f9fafb;
        border-radius: 8px 8px 0 0;
    }
    
    .camera-modal-header h3 {
        margin: 0;
        color: #1f2937;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .camera-modal-body {
        padding: 1.5rem;
    }
    
    .camera-modal-body p {
        margin-bottom: 1rem;
        color: #4b5563;
        line-height: 1.6;
    }
    
    .camera-loading {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        color: #2563eb;
        font-weight: 500;
        margin-top: 1rem;
    }
    
    .camera-instructions {
        background-color: #f3f4f6;
        padding: 1rem;
        border-radius: 6px;
        margin-top: 1rem;
    }
    
    .camera-instructions h4 {
        margin: 0 0 0.75rem 0;
        color: #1f2937;
    }
    
    .camera-instructions ul {
        margin: 0.5rem 0;
        padding-left: 1.5rem;
    }
    
    .camera-instructions li {
        margin-bottom: 0.5rem;
        color: #4b5563;
    }
    
    .camera-modal-footer {
        padding: 1rem 1.5rem;
        border-top: 1px solid #e5e7eb;
        display: flex;
        gap: 0.75rem;
        justify-content: flex-end;
    }
    
    .camera-status {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.75rem 1rem;
        border-radius: 6px;
        margin-bottom: 1rem;
        font-weight: 500;
    }
    
    .camera-status-checking {
        background-color: #dbeafe;
        color: #1e40af;
        border: 1px solid #93c5fd;
    }
    
    .camera-status-success {
        background-color: #d1fae5;
        color: #065f46;
        border: 1px solid #6ee7b7;
    }
    
    .camera-status-error {
        background-color: #fee2e2;
        color: #991b1b;
        border: 1px solid #fca5a5;
    }
    
    .camera-notification {
        position: fixed;
        top: 1rem;
        right: 1rem;
        max-width: 300px;
        z-index: 9999;
        border-radius: 6px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transform: translateX(110%);
        transition: transform 0.3s ease;
    }
    
    .camera-notification.show {
        transform: translateX(0);
    }
    
    .camera-notification .notification-content {
        padding: 1rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    
    .camera-success .notification-content {
        background-color: #ecfdf5;
        color: #064e3b;
        border-left: 4px solid #10b981;
    }
    
    .start-exam-button.disabled {
        background-color: #9ca3af !important;
        cursor: not-allowed !important;
        opacity: 0.6;
    }
    
    .start-exam-button.disabled:hover {
        background-color: #9ca3af !important;
        transform: none !important;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    /* Dark theme styles */
    body.dark-theme .camera-modal-content {
        background-color: #1f2937;
        color: #e5e7eb;
    }
    
    body.dark-theme .camera-modal-header {
        background-color: #374151;
        border-color: #4b5563;
    }
    
    body.dark-theme .camera-modal-header h3 {
        color: #e5e7eb;
    }
    
    body.dark-theme .camera-modal-body p {
        color: #d1d5db;
    }
    
    body.dark-theme .camera-instructions {
        background-color: #374151;
    }
    
    body.dark-theme .camera-instructions h4 {
        color: #e5e7eb;
    }
    
    body.dark-theme .camera-instructions li {
        color: #d1d5db;
    }
    
    body.dark-theme .camera-modal-footer {
        border-color: #4b5563;
    }
`;

// Add styles to document
const cameraStyleElement = document.createElement('style');
cameraStyleElement.textContent = cameraStyles;
document.head.appendChild(cameraStyleElement);
// Integration function to modify the existing startExam function
function integrateWithExistingExam() {
    // Store the original startExam function
    const originalStartExam = window.startExam;
    
    // Override the startExam function
    window.startExam = function() {
        // Check if camera permission is granted before starting
        if (!CameraPermissionHandler.isPermissionGranted()) {
            alert('Camera access is required to start the exam. Please grant camera permission first.');
            return;
        }
        
        // Call the original startExam function
        if (originalStartExam) {
            originalStartExam.call(this);
        }
    };
    
    // Initialize camera check when page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Wait a bit for the start overlay to be created
        setTimeout(() => {
            CameraPermissionHandler.initialize();
        }, 500);
    });
}

if (typeof window !== 'undefined') {
    integrateWithExistingExam();
}
</script>


    <script>

/**
 * Exam Integrity Monitoring Module
 * 
 * This module provides functionality for:
 * 1. Integrity monitoring (tab changes, mouse exits, fullscreen controls, copy/paste prevention, etc.)
 * 2. Activity ping tracking to server
 * 3. Webcam capture and submission
 * 
 * Usage: Include this script and initialize with examIntegrity.init()
 */

const examIntegrity = (function() {
    // Configuration
    const config = {
        maxViolations: 999,                // Maximum violations before auto-submit
        maxRefreshes: 999,                 // Maximum allowed page refreshes
        pingInterval: 20000,             // Ping interval in ms (20 seconds)
        tabFocusCooldown: 1000,          // Time between focus events in ms
        webcamCaptureInterval: 5000,     // Webcam capture interval in ms
        resizeCooldown: 500,             // Time between resize events in ms
        maxResizeAttempts: 999             // Maximum resize attempts before violation
    };

    // State variables
    let state = {
        examStarted: false,
        isFullscreenActive: false,
        lastTabFocusTime: 0,
        pingIntervalId: null,
        resizeAttempts: 0,
        lastResizeTime: 0,
        submitting: false,
        autoSubmitCallback: null,        // Callback when auto submitting
        
        // Violation counters
        violations: {
            tabChangeCount: 0,
            mouseOutCount: 0,
            fullscreenExitCount: 0,
            copyAttemptCount: 0,
            pasteAttemptCount: 0,
            focusChangeCount: 0,
            refreshViolationCount: 0
        },
        totalViolations: 0
    };

    // DOM Elements (to be initialized)
    let elements = {
        tabChangeCount: null,
        mouseOutCount: null,
        fullscreenExitCount: null,
        copyAttemptCount: null,
        pasteAttemptCount: null,
        focusChangeCount: null,
        refreshViolationCount: null,
        totalViolations: null,
        lastEvent: null,
        notificationContainer: null
    };

    // URLs for API endpoints
    const apiEndpoints = {
        integrityUpdate: '/update-integrity',
        activityPing: '/dashboard/see-active',
        saveImage: '/save-image'
    };

    // User and exam info
    let examInfo = {
        examId: null,
        userId: null
    };

    /**
     * Initialize the integrity module
     * @param {Object} options Configuration options
     */
    function init(options = {}) {
        console.log('Initializing exam integrity module...');
        
        // Merge options with defaults
        if (options.config) {
            Object.assign(config, options.config);
        }
        
        // Set exam info
        if (options.examId) examInfo.examId = options.examId;
        if (options.userId) examInfo.userId = options.userId;
        
        // Initialize from localStorage if available
        state.examStarted = localStorage.getItem('examStarted') === 'true';
        
        // Auto-submit callback
        if (options.onAutoSubmit && typeof options.onAutoSubmit === 'function') {
            state.autoSubmitCallback = options.onAutoSubmit;
        }
        
        // Set API endpoints
        if (options.apiEndpoints) {
            Object.assign(apiEndpoints, options.apiEndpoints);
        }
        
        // Initialize UI elements
        initElements();
        
        // Initialize event listeners
        if (state.examStarted) {
            setupEventListeners();
            handleRefreshDetection();
            startActivityPing();
            
            if (options.startWebcam) {
                startWebcamCapture();
            }
        }
        
        // Add style for notifications
        const style = document.createElement('style');
        style.id = 'notificationAnimations';
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-20px); }
                to { opacity: 1; transform: translateY(0); }
            }
            @keyframes fadeOut {
                from { opacity: 1; transform: translateY(0); }
                to { opacity: 0; transform: translateY(-20px); }
            }
        `;
        document.head.appendChild(style);
        
        return {
            start,
            stop,
            enterFullscreen,
            handleRefreshDetection,
            startWebcamCapture,
            showNotification,
            getViolationCounts,
            preventBackButton
        };
    }

    /**
     * Initialize UI elements
     */
    function initElements() {
        // Get DOM elements for counters
        elements.tabChangeCount = document.getElementById('tabChangeCount');
        elements.mouseOutCount = document.getElementById('mouseOutCount');
        elements.fullscreenExitCount = document.getElementById('fullscreenExitCount');
        elements.copyAttemptCount = document.getElementById('copyAttemptCount');
        elements.pasteAttemptCount = document.getElementById('pasteAttemptCount');
        elements.focusChangeCount = document.getElementById('focusChangeCount');
        elements.refreshViolationCount = document.getElementById('refreshViolationCount');
        elements.totalViolations = document.getElementById('totalViolations');
        elements.lastEvent = document.getElementById('lastEvent');
        
        // Create notification container if it doesn't exist
        elements.notificationContainer = document.getElementById('notificationContainer');
        if (!elements.notificationContainer) {
            elements.notificationContainer = document.createElement('div');
            elements.notificationContainer.id = 'notificationContainer';
            elements.notificationContainer.style.position = 'fixed';
            elements.notificationContainer.style.top = '10px';
            elements.notificationContainer.style.right = '10px';
            elements.notificationContainer.style.zIndex = '9999';
            document.body.appendChild(elements.notificationContainer);
        }
    }

    /**
     * Start integrity monitoring
     */
    function start(examId, userId) {
        if (examId) examInfo.examId = examId;
        if (userId) examInfo.userId = userId;
        
        state.examStarted = true;
        localStorage.setItem('examStarted', 'true');
        localStorage.setItem('examRefreshCount', '0');
        
        setupEventListeners();
        startActivityPing();
        preventBackButton();
        enterFullscreen();
        
        updateUI();
        updateStatus('Exam integrity monitoring started');
    }

    /**
     * Stop integrity monitoring
     */
    function stop() {
        state.examStarted = false;
        localStorage.removeItem('examStarted');
        localStorage.removeItem('examRefreshCount');
        
        if (state.pingIntervalId) {
            clearInterval(state.pingIntervalId);
            state.pingIntervalId = null;
        }
        
        updateStatus('Exam integrity monitoring stopped');
    }

    /**
     * Setup event listeners for integrity monitoring
     */
    function setupEventListeners() {
        // Fullscreen change events
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        // Tab visibility and focus events
        document.addEventListener('visibilitychange', handleTabChange);
        window.addEventListener('blur', handleFocusChange);
        window.addEventListener('focus', handleFocusChange);
        
        // Mouse exit detection
        document.addEventListener('mouseout', handleMouseOut);
        
        // Copy/paste prevention
        document.addEventListener('copy', handleCopyAttempt);
        document.addEventListener('paste', handlePasteAttempt);
        
        // Keyboard shortcuts prevention
        document.addEventListener('keydown', preventKeyboardShortcuts);
        
        // Prevent context menu
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        // Window resize detection (potential DevTools)
        window.addEventListener('resize', handleResize);
        
        // Before unload warning
        window.addEventListener('beforeunload', handleBeforeUnload);
        
        // Ensure fullscreen on click
        document.addEventListener('click', () => {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && !document.msFullscreenElement && 
                state.examStarted) {
                enterFullscreen();
                updateStatus("Fullscreen mode ensured after click");
            }
        });
    }

    /**
     * Prevent keyboard shortcuts
     */
    function preventKeyboardShortcuts(e) {
        if (!state.examStarted) return;
        
        // Prevent dev tools and refresh shortcuts
        if (e.key === 'F12' || 
            (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) || 
            (e.ctrlKey && e.key === 'U') ||
            e.key === 'F5' || 
            ((e.metaKey || e.ctrlKey) && e.key === 'r') ||
            e.key === 'F11' || 
            (e.metaKey && e.shiftKey && e.key === 'f') ||
            (e.altKey && e.key === 'Tab') ||
            (e.metaKey && e.key === 'w') || 
            (e.key === 'F4' && e.altKey)) {
            
            e.preventDefault();
            e.stopPropagation();
            showNotification("This action is not allowed during the exam.");
            return false;
        }
        
        // If Escape key is pressed, prevent default action and re-enter fullscreen
        if (e.key === 'Escape' && state.examStarted) {
            e.preventDefault();
            // Small delay to ensure the fullscreen exit completes first
            setTimeout(enterFullscreen, 100);
            return false;
        }
    }

    /**
     * Prevent back button
     */
    function preventBackButton() {
        window.history.pushState(null, "", window.location.href);
        window.onpopstate = function() {
            window.history.pushState(null, "", window.location.href);
        };
    }

    /**
     * Update UI with violation counts
     */
    function updateUI() {
        if (!state.examStarted) return;
        
        // Update DOM elements if they exist
        if (elements.tabChangeCount) elements.tabChangeCount.textContent = state.violations.tabChangeCount;
        if (elements.mouseOutCount) elements.mouseOutCount.textContent = state.violations.mouseOutCount;
        if (elements.fullscreenExitCount) elements.fullscreenExitCount.textContent = state.violations.fullscreenExitCount;
        if (elements.copyAttemptCount) elements.copyAttemptCount.textContent = state.violations.copyAttemptCount;
        if (elements.pasteAttemptCount) elements.pasteAttemptCount.textContent = state.violations.pasteAttemptCount;
        if (elements.focusChangeCount) elements.focusChangeCount.textContent = state.violations.focusChangeCount;
        if (elements.refreshViolationCount) elements.refreshViolationCount.textContent = state.violations.refreshViolationCount;
        if (elements.totalViolations) elements.totalViolations.textContent = state.totalViolations;
    }

    /**
     * Update status message
     */
    function updateStatus(message) {
        if (!state.examStarted) return;
        
        if (elements.lastEvent) {
            elements.lastEvent.textContent = message;
        }
        console.log('Integrity status:', message);
    }

    /**
     * Handle tab change events
     */
    function handleTabChange() {
        if (!state.examStarted) return;
        
        if (document.hidden) {
            // Only count tab change if it's not immediately after a focus change
            const currentTime = Date.now();
            if (currentTime - state.lastTabFocusTime > config.tabFocusCooldown) {
                state.violations.tabChangeCount++;
                state.totalViolations++;
                sendIntegrityUpdate("tabChanges");
                updateStatus("Tab change detected");
                updateUI();
                checkAndTriggerAutoSubmit();
            }
        }
    }

    /**
     * Handle mouse leaving the window
     */
    function handleMouseOut(event) {
        if (!state.examStarted) return;
        
        // Check if mouse actually left the window
        if (event.clientX < 0 || event.clientX > window.innerWidth - 1 || 
            event.clientY < 0 || event.clientY > window.innerHeight - 1) {
            state.violations.mouseOutCount++;
            state.totalViolations++;
            sendIntegrityUpdate("mouseOuts");
            updateStatus("Mouse left workspace");
            showNotification("Mouse Going Out is not allowed");
            updateUI();
            checkAndTriggerAutoSubmit();
        }
    }

    /**
     * Handle window focus changes
     */
    function handleFocusChange(event) {
        if (!state.examStarted) return;
        
        if (event.type === 'blur') {
            // Only count focus change if it's not immediately after a tab change
            const currentTime = Date.now();
            if (currentTime - state.lastTabFocusTime > config.tabFocusCooldown) {
                state.violations.focusChangeCount++;
                state.lastTabFocusTime = currentTime;
                
                // Check if this is coming from a tab change or standalone focus change
                if (!document.hidden) {
                    // If document is not hidden, this is a standalone focus change
                    state.totalViolations++;
                    sendIntegrityUpdate("focusChanges");
                    updateStatus("Focus change detected");
                    updateUI();
                    checkAndTriggerAutoSubmit();
                }
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    function handleFullscreenChange() {
        if (!state.examStarted) return;
        
        if (!document.fullscreenElement && !document.webkitFullscreenElement && 
            !document.mozFullScreenElement && !document.msFullscreenElement) {
            state.violations.fullscreenExitCount++;
            state.totalViolations++;
            showNotification("Exiting fullscreen is not allowed during the exam.");
            
            // Give a short delay before forcing back to fullscreen (helps with Mac transition)
            setTimeout(enterFullscreen, 500);
            
            sendIntegrityUpdate("fullscreenExits");
            updateStatus("Fullscreen exited");
            updateUI();
            checkAndTriggerAutoSubmit();
        } else {
            if (!state.isFullscreenActive) {
                state.isFullscreenActive = true;
            }
            updateStatus("Fullscreen entered");
        }
    }

    /**
     * Enter fullscreen mode
     */
    function enterFullscreen() {
        const elem = document.documentElement;
        
        // Don't attempt to enter fullscreen if already in fullscreen mode
        if (document.fullscreenElement || document.webkitFullscreenElement || 
            document.mozFullScreenElement || document.msFullscreenElement) {
            return;
        }
        
        try {
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { // Safari
                elem.webkitRequestFullscreen();
            } else if (elem.mozRequestFullScreen) { // Firefox
                elem.mozRequestFullScreen();
            } else if (elem.msRequestFullscreen) { // IE/Edge
                elem.msRequestFullscreen();
            }
        } catch (error) {
            console.error("Fullscreen error:", error);
            showNotification("Fullscreen mode failed. Please try again.");
        }
    }

    /**
     * Handle copy attempts
     */
    function handleCopyAttempt(e) {
        if (!state.examStarted) return;
        
        e.preventDefault();
        state.violations.copyAttemptCount++;
        state.totalViolations++;
        sendIntegrityUpdate("copyAttempts");
        updateStatus("Copy attempt detected");
        updateUI();
        checkAndTriggerAutoSubmit();
    }

    /**
     * Handle paste attempts
     */
    function handlePasteAttempt(e) {
        if (!state.examStarted) return;
        
        e.preventDefault();
        state.violations.pasteAttemptCount++;
        state.totalViolations++;
        sendIntegrityUpdate("pasteAttempts");
        updateStatus("Paste attempt detected");
        updateUI();
        checkAndTriggerAutoSubmit();
    }

    /**
     * Handle resize events (potential DevTools)
     */
    function handleResize() {
        if (!state.examStarted) return;
        
        const currentTime = Date.now();
        
        // Check if we're within the cooldown period
        if (currentTime - state.lastResizeTime < config.resizeCooldown) {
            // Count this as another attempt within the same period
            state.resizeAttempts++;
            
            // Check if max attempts exceeded
            if (state.resizeAttempts >= config.maxResizeAttempts) {
                // Only show notification and count as violation if not due to Mac-specific events
                if (Math.abs(window.innerHeight - window.screen.height) > 100) {
                    showNotification(`DevTools detected! Your exam is being monitored.`, 'error');
                    state.totalViolations++;
                    sendIntegrityUpdate("resizeViolations");
                    updateStatus("Multiple suspicious resize events detected");
                    updateUI();
                    
                    // Show the violation modal and trigger auto-submit
                    showViolationModal(() => {
                        if (state.autoSubmitCallback) {
                            state.autoSubmitCallback("resize_violations");
                        }
                    });
                }
            }
        } else {
            // First resize attempt in a new period
            state.resizeAttempts = 1;
            
            if (state.resizeAttempts > 1) {
                showNotification(`Window resize detected. This is being monitored.`);
            }
        }
        
        // Update the timestamp
        state.lastResizeTime = currentTime;
        
        // Check if total violations are too high
        checkAndTriggerAutoSubmit();
    }

    /**
     * Handle beforeunload event
     */
    function handleBeforeUnload(e) {
        if (!state.examStarted) return;
        
        if (state.pingIntervalId) {
            clearInterval(state.pingIntervalId);
            
            // Send final ping with status=inactive
            fetch(apiEndpoints.activityPing, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    examId: examInfo.examId,
                    userId: examInfo.userId,
                    timestamp: new Date().toISOString(),
                    status: 'inactive'
                }),
                keepalive: true
            });
        }
        
        if (state.submitting) {
            return;
        }
        
        e.preventDefault();
        e.returnValue = '';
        return '';
    }

    /**
     * Handle refresh detection
     */
    function handleRefreshDetection() {
        // Check if there's a saved refresh count
        let refreshCount = parseInt(localStorage.getItem('examRefreshCount') || '0');
        
        if (state.examStarted) {
            refreshCount++;
            localStorage.setItem('examRefreshCount', refreshCount.toString());
        }
        
        // Count this as a violation if it's not the first load
        if (refreshCount > 1) {
            state.violations.refreshViolationCount = refreshCount - 1; // Don't count the initial load
            state.totalViolations += 1; // Increment total violations by 1 for this refresh
            
            // Send refresh event to server for logging
            sendIntegrityUpdate("pageRefresh");
            updateStatus("Page refresh detected");
            updateUI();
            
            // Check if exceeded maximum allowed refreshes
            if (refreshCount > config.maxRefreshes) {
                showNotification(`Maximum page refreshes (${config.maxRefreshes}) exceeded. Your exam is being submitted.`, 'error');
                
                if (state.autoSubmitCallback) {
                    state.autoSubmitCallback("excessive_refreshes");
                }
                
                return false;
            }
        }
        
        return true;
    }

    /**
     * Check and trigger auto-submit if violations are too high
     */
    function checkAndTriggerAutoSubmit() {
        if (!state.examStarted) return;
        
        if (state.totalViolations >= config.maxViolations) {
            updateStatus("Auto-submitting test due to integrity violations");
            const modalOverlay = showViolationModal(() => {
                if (state.autoSubmitCallback) {
                    state.autoSubmitCallback("integrity_violations");
                }
            });
        }
    }

    /**
     * Show violation modal
     */
    function showViolationModal(callback) {
        // Create modal container
        const modalOverlay = document.createElement('div');
        modalOverlay.style.position = 'fixed';
        modalOverlay.style.top = '0';
        modalOverlay.style.left = '0';
        modalOverlay.style.width = '100%';
        modalOverlay.style.height = '100%';
        modalOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        modalOverlay.style.display = 'flex';
        modalOverlay.style.justifyContent = 'center';
        modalOverlay.style.alignItems = 'center';
        modalOverlay.style.zIndex = '10000';
        
        // Create modal content
        const modalContent = document.createElement('div');
        modalContent.style.backgroundColor = '#fff';
        modalContent.style.padding = '25px';
        modalContent.style.borderRadius = '10px';
        modalContent.style.maxWidth = '500px';
        modalContent.style.width = '80%';
        modalContent.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.3)';
        modalContent.style.textAlign = 'center';
        
        // Add warning icon
        const warningIcon = document.createElement('div');
        warningIcon.innerHTML = '';
        warningIcon.style.fontSize = '4rem';
        warningIcon.style.marginBottom = '15px';
        modalContent.appendChild(warningIcon);
        
        // Add title
        const title = document.createElement('h2');
        title.textContent = 'Critical Violation Alert';
        title.style.color = '#d9534f';
        title.style.marginBottom = '15px';
        modalContent.appendChild(title);
        
        // Add message
        const message = document.createElement('p');
        message.textContent = `You have committed ${state.totalViolations} or more integrity violations. Your exam will be automatically submitted.`;
        message.style.marginBottom = '20px';
        message.style.fontSize = '1.1rem';
        message.style.color = '#000';
        modalContent.appendChild(message);
        
        // Add violations list
        const violationsList = document.createElement('div');
        violationsList.style.textAlign = 'left';
        violationsList.style.marginBottom = '20px';
        violationsList.style.padding = '10px';
        violationsList.style.backgroundColor = '#f8d7da';
        violationsList.style.borderRadius = '5px';
        violationsList.style.color = '#000';
        
        let violationsHTML = '<strong>Violations detected:</strong><ul style="margin-top: 10px;">';
        
        // Add each violation type with count
        if (state.violations.tabChangeCount > 0) violationsHTML += `<li>Tab changes: ${state.violations.tabChangeCount}</li>`;
        if (state.violations.mouseOutCount > 0) violationsHTML += `<li>Mouse left window: ${state.violations.mouseOutCount}</li>`;
        if (state.violations.fullscreenExitCount > 0) violationsHTML += `<li>Fullscreen exits: ${state.violations.fullscreenExitCount}</li>`;
        if (state.violations.copyAttemptCount > 0) violationsHTML += `<li>Copy attempts: ${state.violations.copyAttemptCount}</li>`;
        if (state.violations.pasteAttemptCount > 0) violationsHTML += `<li>Paste attempts: ${state.violations.pasteAttemptCount}</li>`;
        if (state.violations.focusChangeCount > 0) violationsHTML += `<li>Focus changes: ${state.violations.focusChangeCount}</li>`;
        if (state.violations.refreshViolationCount > 0) violationsHTML += `<li>Page refreshes: ${state.violations.refreshViolationCount}</li>`;
        
        violationsHTML += '</ul>';
        violationsList.innerHTML = violationsHTML;
        modalContent.appendChild(violationsList);
        
        // Add countdown text
        const countdown = document.createElement('p');
        countdown.textContent = 'Submitting exam in 5 seconds...';
        countdown.style.fontWeight = 'bold';
        countdown.style.color = '#000';
        modalContent.appendChild(countdown);
        
        modalOverlay.appendChild(modalContent);
        document.body.appendChild(modalOverlay);
        
        // Start countdown
        let seconds = 5;
        const countdownInterval = setInterval(() => {
            seconds--;
            countdown.textContent = `Submitting exam in ${seconds} second${seconds !== 1 ? 's' : ''}...`;
            
            if (seconds <= 0) {
                clearInterval(countdownInterval);
                if (callback && typeof callback === 'function') {
                    callback();
                }
            }
        }, 1000);
        
        return modalOverlay;
    }

    /**
     * Show notification
     */
    function showNotification(message, type = 'warning') {
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.style.backgroundColor = type === 'warning' ? '#fff3cd' : '#f8d7da';
        notification.style.color = type === 'warning' ? '#856404' : '#721c24';
        notification.style.padding = '10px 15px';
        notification.style.marginBottom = '10px';
        notification.style.borderRadius = '4px';
        notification.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
        notification.style.width = '300px';
        notification.style.animation = 'fadeIn 0.3s ease-out';
        notification.innerHTML = message;
        
        // Add to container
        elements.notificationContainer.appendChild(notification);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            notification.style.animation = 'fadeOut 0.3s ease-in';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 5000);
        
        return notification;
    }

    /**
     * Send integrity update to server
     */
    function sendIntegrityUpdate(eventType) {
        if (!state.examStarted) return;
        
        const data = {
            examId: examInfo.examId,
            userId: examInfo.userId,
            eventType: eventType
        };

        fetch(apiEndpoints.integrityUpdate, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        })
        .then(response => response.json())
        .then(data => console.log('Integrity event logged:', data))
        .catch(error => console.error('Error sending integrity update:', error));
    }

    /**
     * Start sending activity pings to server
     */
    function startActivityPing() {
        if (state.pingIntervalId) {
            clearInterval(state.pingIntervalId);
        }
        
        // Send initial ping
        sendActivityPing();
        
        // Set up interval for regular pings
        state.pingIntervalId = setInterval(sendActivityPing, config.pingInterval);
    }

    /**
     * Send activity ping to server
     */
    function sendActivityPing() {
        if (!state.examStarted) return;
        
        fetch(apiEndpoints.activityPing, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                examId: examInfo.examId,
                userId: examInfo.userId,
                timestamp: new Date().toISOString()
            })
        })
        .then(response => {
            if (!response.ok) {
                console.error('Failed to send activity ping');
            }
        })
        .catch(error => {
            console.error('Error sending activity ping:', error);
        });
    }

    /**
     * Start webcam capture
     */
    function startWebcamCapture() {
        const canvas = document.createElement('canvas');
        canvas.width = 320;
        canvas.height = 240;
        canvas.style.display = 'none';
        document.body.appendChild(canvas);
        
        const context = canvas.getContext('2d');
        
        // Check if media devices API is supported
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            console.error("MediaDevices API not supported");
            showNotification("Your browser doesn't support webcam capture. Please use a modern browser.", 'error');
            return;
        }

        navigator.mediaDevices.getUserMedia({ 
            video: { 
                width: { ideal: 320 },
                height: { ideal: 240 },
                facingMode: "user"
            } 
        })
        .then((stream) => {
            const video = document.createElement('video');
            video.srcObject = stream;
            video.style.display = 'none';
            document.body.appendChild(video);
            video.play();
            
            // Wait for video to be ready
            video.onloadedmetadata = () => {
                // Set up snapshot interval
                setInterval(() => {
                    try {
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);
                        
                        canvas.toBlob((blob) => {
                            if (!blob) return;
                            
                            const formData = new FormData();
                            formData.append('image', blob, `capture-${Date.now()}.png`);
                            formData.append('userId', examInfo.userId);
                            formData.append('examId', examInfo.examId);
                            
                            fetch(apiEndpoints.saveImage, { 
                                method: 'POST',
                                body: formData,
                            })
                            .then(response => response.json())
                            .then(data => console.log('Image saved:', data))
                            .catch(error => console.error('Error saving image:', error));
                        }, 'image/png');
                    } catch (err) {
                        console.error("Error capturing webcam frame:", err);
                    }
                }, config.webcamCaptureInterval);
            };
        })
        .catch((error) => {
            console.error("Error accessing webcam:", error);
            showNotification("Unable to access the webcam. Please ensure your camera is connected and you've allowed permission.", 'error');
        });
    }

    /**
     * Get current violation counts
     */
    function getViolationCounts() {
        return {
            ...state.violations,
            totalViolations: state.totalViolations
        };
    }

    // Return public API
    return {
        init,
        start,
        stop,
        enterFullscreen,
        handleRefreshDetection,
        startWebcamCapture,
        showNotification,
        getViolationCounts,
        preventBackButton
    };
})();

</script>


    <script>
    // Judge0 API base URL
const JUDGE0_API_URL = 'https://b86c-119-226-236-129.ngrok-free.app/submissions';
    
    // Store the exam data in localStorage when the page loads
    window.addEventListener('DOMContentLoaded', () => {
        // Assuming 'exam' is passed from the server to the EJS template
        const examData = <%- JSON.stringify(exam) %>;
          const mainContainer = document.querySelector('.main-container');
            const header = document.querySelector('.header');
             if (mainContainer && header) {
        mainContainer.style.display = 'none';
        header.style.display = 'none';
        
        // Create start exam overlay
        const startOverlay = document.createElement('div');
        startOverlay.className = 'start-exam-overlay';
        startOverlay.innerHTML = `
            <div class="start-exam-container">
                <div class="start-exam-header">
                    <div class="header-logo">
                        <i class="fas fa-graduation-cap"></i> Exam Portal
                    </div>
                </div>
                <div class="start-exam-content">
                    <div class="start-exam-title" id="examTitleStart">Loading exam...</div>
                    <div class="start-exam-info">
                        <div class="info-item">
                            <i class="fas fa-clock"></i>
                            <span id="examDurationStart">-- minutes</span>
                        </div>
                        <div class="info-item">
                            <i class="fas fa-tasks"></i>
                            <span id="examTypeStart">--</span>
                        </div>
                        <div class="info-item">
                            <i class="fas fa-info-circle"></i>
                            <span id="examQuestionsStart">-- questions</span>
                        </div>
                    </div>
                    <div class="start-exam-instructions">
                        <h3><i class="fas fa-list-ul"></i> Instructions</h3>
                        <ul>
                            <li>The timer will start as soon as you begin the exam.</li>
                            <li>Answer all questions to the best of your ability.</li>
                            <li>You can navigate between questions using the side panel.</li>
                            <li>Submit your exam when you're finished.</li>
                            <li>Don't refresh or leave the page during the exam.</li>
                        </ul>
                    </div>
                    <div class="start-button-container">
                        <button id="startExamButton" class="start-exam-button">
                            <i class="fas fa-play"></i> Start Exam
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(startOverlay);

    const userId = document.getElementById('user').textContent;
    const examId = document.getElementById('exam').textContent;
    
    // Initialize the module with configuration
    const integrity = examIntegrity.init({
        // Required exam information
        examId: examId,
        userId: userId,
        
        // Optional: Custom API endpoints
        apiEndpoints: {
            integrityUpdate: '/update-integrity',
            activityPing: '/dashboard/see-active',
            saveImage: '/save-image'
        },
        
        // Optional: Custom behavior configuration
        config: {
            maxViolations: 5,                // Default: 3
            maxRefreshes: 3,                 // Default: 2
            pingInterval: 30000,             // Default: 20000 (20 seconds)
            webcamCaptureInterval: 10000     // Default: 5000 (5 seconds)
        },
        
        // Optional: Callback when violations trigger auto-submit
        onAutoSubmit: function(reason) {
            console.log(`Auto-submitting exam due to: ${reason}`);
            
            // Your custom submit logic
            submitExam()
            
            // Optional: Redirect after submission

        },
        
        // Optional: Start webcam automatically on init
        startWebcam: false
    });
    
    // Start monitoring when the exam begins
  
    // Example: Submit exam button

        
        // Get exam data and update the title
if (examData) {
            document.getElementById('examTitleStart').textContent = examData.name;
            document.getElementById('examDurationStart').textContent = `${examData.duration} minutes`;
            
            // Display exam type
            let examType = '';
            if (examData.questionType === "mcq") {
                examType = 'Multiple Choice';
            } else if (examData.questionType === "coding") {
                examType = 'Coding';
            } else if (examData.questionType === "mcq&coding") {
                examType = 'Mixed (MCQ & Coding)';
            }
            document.getElementById('examTypeStart').textContent = examType;
            
            // Display question count
            let totalQuestions = getTotalQuestions(examData);
            document.getElementById('examQuestionsStart').textContent = `${totalQuestions} questions`;
        }
        
        // Add event listener to start exam button
        document.getElementById('startExamButton').addEventListener('click', startExam);
    }



    function startExam() {
    // Remove the overlay
    const startOverlay = document.querySelector('.start-exam-overlay');
    if (startOverlay) {
        startOverlay.remove();
    }
    
    // Show the main content
    const mainContainer = document.querySelector('.main-container');
    const header = document.querySelector('.header');
    
    if (mainContainer && header) {
        mainContainer.style.display = 'grid';
        header.style.display = 'flex';
    }
    
    // Initialize the exam
    initializeExam();
    
    // Start the timer
    const endTime = new Date().getTime() + (JSON.parse(localStorage.getItem('currentExam')).duration * 60 * 1000);
    localStorage.setItem('examEndTime', endTime.toString());

       const userId = document.getElementById('user').textContent;
    const examId = document.getElementById('exam').textContent;
    
    // Initialize the module with configuration
    const integrity = examIntegrity.init({
        // Required exam information
        examId: examId,
        userId: userId,
        
        // Optional: Custom API endpoints
        apiEndpoints: {
            integrityUpdate: '/update-integrity',
            activityPing: '/dashboard/see-active',
            saveImage: '/save-image'
        },
        
        // Optional: Custom behavior configuration
        config: {
            maxViolations: 5,                // Default: 3
            maxRefreshes: 3,                 // Default: 2
            pingInterval: 30000,             // Default: 20000 (20 seconds)
            webcamCaptureInterval: 10000     // Default: 5000 (5 seconds)
        },
        
        // Optional: Callback when violations trigger auto-submit
        onAutoSubmit: function(reason) {
            console.log(`Auto-submitting exam due to: ${reason}`);
            
            // Your custom submit logic
            submitExam()
            
            // Optional: Redirect after submission

        },
        
        // Optional: Start webcam automatically on init
        startWebcam: false
    });
    
        // Start the integrity monitoringsss
        integrity.start();
        
        // Start webcam capture if not auto-started
        integrity.startWebcamCapture();
        
        // Enter fullscreen mode
        integrity.enterFullscreen();
        
        // Prevent back button navigation
        integrity.preventBackButton();
        
        // Show example notification
        integrity.showNotification('Exam has started. Integrity monitoring is active.');
        
        // Hide the start button and show exam content
        this.style.display = 'none';
        document.getElementById('examContent').style.display = 'block';

    
    startExamTimer();
}
const startExamStyles = `
    .start-exam-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #f3f4f6;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        padding: 1rem;
    }

    body.dark-theme .start-exam-overlay {
        background-color: #1e1e2d;
    }

    .start-exam-container {
        max-width: 800px;
        width: 100%;
        display: flex;
        flex-direction: column;
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-lg);
        overflow: hidden;
        background-color: var(--white);
        animation: slideUp 0.5s ease;
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    body.dark-theme .start-exam-container {
        background-color: #252636;
        color: #e5e7eb;
    }

    .start-exam-header {
        background-color: var(--primary);
        color: var(--white);
        padding: 1rem 1.5rem;
        display: flex;
        align-items: center;
    }

    .start-exam-content {
        padding: 2rem;
    }

    .start-exam-title {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 1.5rem;
        color: var(--dark);
        text-align: center;
    }

    body.dark-theme .start-exam-title {
        color: #e5e7eb;
    }

    .start-exam-info {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 2rem;
        margin-bottom: 2rem;
        padding: 1rem;
        background-color: #f8fafc;
        border-radius: var(--border-radius);
    }

    body.dark-theme .start-exam-info {
        background-color: #2d2d3f;
    }

    .info-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .info-item i {
        color: var(--primary);
        font-size: 1.25rem;
    }

    .start-exam-instructions {
        margin-bottom: 2rem;
        padding: 1.5rem;
        background-color: #f8fafc;
        border-radius: var(--border-radius);
        border-left: 4px solid var(--primary);
    }

    body.dark-theme .start-exam-instructions {
        background-color: #2d2d3f;
    }

    .start-exam-instructions h3 {
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--primary);
    }

    .start-exam-instructions ul {
        list-style-type: none;
        padding-left: 1.5rem;
    }

    .start-exam-instructions li {
        margin-bottom: 0.5rem;
        position: relative;
    }

    .start-exam-instructions li:before {
        content: "";
        color: var(--primary);
        font-weight: bold;
        display: inline-block;
        width: 1rem;
        position: absolute;
        left: -1rem;
    }

    .start-button-container {
        display: flex;
        justify-content: center;
    }

    .start-exam-button {
        padding: 1rem 3rem;
        font-size: 1.25rem;
        background-color: var(--success);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
    }

    .start-exam-button:hover {
        background-color: #059669;
        transform: translateY(-2px);
        box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
    }

    .start-exam-button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    @media (max-width: 768px) {
        .start-exam-info {
            flex-direction: column;
            gap: 1rem;
            align-items: flex-start;
        }
        
        .start-exam-title {
            font-size: 1.5rem;
        }
        
        .start-exam-button {
            padding: 0.75rem 2rem;
            font-size: 1.1rem;
        }
    }
`;

// Append the styles to the document
const styleElement = document.createElement('style');
styleElement.textContent += startExamStyles;
document.head.appendChild(styleElement);
        // Store the entire exam object
        localStorage.setItem('currentExam', JSON.stringify(examData));
        
        // Store questions separately for easier access
        if (examData.questionType === "mcq") {
            localStorage.setItem('mcqQuestions', JSON.stringify(examData.mcqQuestions));
        } else if (examData.questionType === "coding") {
            localStorage.setItem('codingQuestions', JSON.stringify(examData.codingQuestions));
        } else if (examData.questionType === "mcq&coding") {
            localStorage.setItem('mcqQuestions', JSON.stringify(examData.mcqQuestions));
            localStorage.setItem('codingQuestions', JSON.stringify(examData.codingQuestions));
        }
        
        // Initialize current question index
        localStorage.setItem('currentQuestionIndex', '0');
        
        // Initialize timer if exam has duration
        if (examData.duration) {
            const endTime = new Date().getTime() + (examData.duration * 60 * 1000);
            localStorage.setItem('examEndTime', endTime.toString());
        }
        
        // Initialize empty answers object
        const emptyAnswers = {
            mcq: {},
            coding: {}
        };
        localStorage.setItem('examAnswers', JSON.stringify(emptyAnswers));
        
        // Set up dark mode toggle
        setupDarkModeToggle();
        
        // Trigger the exam initialization
        initializeExam();
    });

    // Function to set up dark mode toggle
    function setupDarkModeToggle() {
        const darkModeToggle = document.getElementById('darkModeToggle');
        const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
        
        // Check if user has a preference stored
        const currentTheme = localStorage.getItem('theme');
        if (currentTheme === 'dark') {
            document.body.classList.add('dark-theme');
            darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
        } else if (currentTheme === 'light') {
            document.body.classList.remove('dark-theme');
            darkModeToggle.innerHTML = '<i class="fas fa-moon"></i>';
        } else if (prefersDarkScheme.matches) {
            document.body.classList.add('dark-theme');
            darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
        }
        
        darkModeToggle.addEventListener('click', () => {
            if (document.body.classList.contains('dark-theme')) {
                document.body.classList.remove('dark-theme');
                darkModeToggle.innerHTML = '<i class="fas fa-moon"></i>';
                localStorage.setItem('theme', 'light');
            } else {
                document.body.classList.add('dark-theme');
                darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
                localStorage.setItem('theme', 'dark');
            }
        });
    }

    // Function to handle exam initialization
    function initializeExam() {
        // Get the exam data from localStorage
        const examData = JSON.parse(localStorage.getItem('currentExam'));
        const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
        
        // Display exam information
        document.getElementById('examTitle').textContent = examData.name;
        document.getElementById('examDuration').textContent = `${examData.duration} minutes`;
        
        // Display exam type
        let examType = '';
        if (examData.questionType === "mcq") {
            examType = 'Multiple Choice';
        } else if (examData.questionType === "coding") {
            examType = 'Coding';
        } else if (examData.questionType === "mcq&coding") {
            examType = 'Mixed (MCQ & Coding)';
        }
        document.getElementById('examType').textContent = examType;
        
        // Determine which question to load first
        loadQuestion(currentIndex);
        
        // Start the timer
        startExamTimer();
        
        // Set up navigation between questions
        setupQuestionNavigation();

        // Set up keyboard shortcuts
        setupKeyboardShortcuts();
        
        // Set up auto-save
        setupAutoSave();
        
        // Update progress indicators
        updateProgress();
    }

    // Function to set up keyboard shortcuts
    function setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Ctrl+Enter to submit exam
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                confirmSubmitExam();
                e.preventDefault();
            }
            
            // Left arrow for previous question
            if (e.altKey && e.key === 'ArrowLeft') {
                const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex'));
                if (currentIndex > 0) {
                    loadQuestion(currentIndex - 1);
                }
                e.preventDefault();
            }
            
            // Right arrow for next question
            if (e.altKey && e.key === 'ArrowRight') {
                const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex'));
                const examData = JSON.parse(localStorage.getItem('currentExam'));
                let totalQuestions = getTotalQuestions(examData);
                
                if (currentIndex < totalQuestions - 1) {
                    loadQuestion(currentIndex + 1);
                }
                e.preventDefault();
            }
        });
    }

    // Helper function to get total questions
function getTotalQuestions(examData) {
    if (!examData) {
        console.error('No exam data provided to getTotalQuestions');
        return 0;
    }
    
    let total = 0;
    
    if (examData.questionType === "mcq") {
        const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions')) || [];
        total = mcqQuestions.length; // Use actual array length instead of examData.numMCQs
    } else if (examData.questionType === "coding") {
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions')) || [];
        total = codingQuestions.length; // Use actual array length instead of examData.numCoding
    } else if (examData.questionType === "mcq&coding") {
        const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions')) || [];
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions')) || [];
        total = mcqQuestions.length + codingQuestions.length; // Calculate from actual arrays
    }
    
    console.log(`Total questions calculated: ${total} for type: ${examData.questionType}`); // Debug log
    return total;
}

    // Function to set up auto-save
    function setupAutoSave() {
        setInterval(() => {
            const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
            const examData = JSON.parse(localStorage.getItem('currentExam'));
            
            if (!examData) return; // Exit if no exam data
            
            if (examData.questionType === "mcq" || examData.questionType === "mcq&coding") {
                // For MCQs, get all radio buttons for the current question
                const mcqRadios = document.querySelectorAll(`input[name="q${currentIndex}"]`);
                mcqRadios.forEach(radio => {
                    if (radio.checked) {
                        const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions'));
                        const question = mcqQuestions[currentIndex];
                        if (question) {
                            const optionIndex = parseInt(radio.value);
                            const optionText = question.options[optionIndex];
                            saveMCQAnswer(question._id, optionIndex, optionText);
                        }
                    }
                });
            }
            
            if (examData.questionType === "coding" || examData.questionType === "mcq&coding") {
                // For coding questions, get the code editor value
                const mcqLength = examData.questionType === "mcq&coding" ? 
                    examData.numMCQs : 0;
                
                if (currentIndex >= mcqLength) {
                    const codingIndex = currentIndex - mcqLength;
                    const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
                    const question = codingQuestions[codingIndex];
                    
                    if (question) {
                        const codeEditor = document.getElementById(`codeEditor-${question._id}`);
                        if (codeEditor) {
                            saveCodingAnswer(question._id, codeEditor.value);
                        }
                    }
                }
            }
            
            // Update progress after auto-save
            updateProgress();
        }, 10000); // Auto-save every 10 seconds
    }

    // Function to update progress indicators
    function updateProgress() {
        const examData = JSON.parse(localStorage.getItem('currentExam'));
        const answers = JSON.parse(localStorage.getItem('examAnswers'));
        
        // Count answered questions
        let answeredCount = 0;
        let totalQuestions = getTotalQuestions(examData);
        
        // Count MCQ answers
        if (answers.mcq) {
            answeredCount += Object.keys(answers.mcq).length;
        }
        
        // Count coding answers
        if (answers.coding) {
            // Only count non-empty coding answers
            for (const questionId in answers.coding) {
                if (answers.coding[questionId] && answers.coding[questionId].trim() !== '') {
                    const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
                    const question = codingQuestions.find(q => q._id === questionId);
                    
                    // Check if the answer is not just the starter code
                    if (question && !isStarterCode(answers.coding[questionId], question)) {
                        answeredCount++;
                    }
                }
            }
        }
        
        // Update progress bar and stats
        const progressPercent = totalQuestions > 0 ? (answeredCount / totalQuestions) * 100 : 0;
        document.getElementById('progressFill').style.width = `${progressPercent}%`;
        document.getElementById('answeredQuestions').textContent = `${answeredCount} answered`;
        document.getElementById('totalQuestions').textContent = `${totalQuestions} total`;
    }

    // Function to load a specific question
    // function loadQuestion(index) {
    //     const examData = JSON.parse(localStorage.getItem('currentExam'));
    //     let question;
    //     let questionType;
        
    //     // Get the appropriate question based on question type and index
    //     if (examData.questionType === "mcq") {
    //         const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions'));
    //         question = mcqQuestions[index];
    //         questionType = "mcq";
    //     } 
    //     else if (examData.questionType === "coding") {
    //         const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
    //         question = codingQuestions[index];
    //         questionType = "coding";
    //     } 
    //     else if (examData.questionType === "mcq&coding") {
    //         // For mixed exams, determine if we're showing MCQ or coding based on index
    //         const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions'));
    //         const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
            
    //         if (index < mcqQuestions.length) {
    //             question = mcqQuestions[index];
    //             questionType = "mcq";
    //         } else {
    //             question = codingQuestions[index - mcqQuestions.length];
    //             questionType = "coding";
    //         }
    //     }
        
    //     // Update the current question index
    //     localStorage.setItem('currentQuestionIndex', index.toString());
        
    //     // Update question number display
    //     document.getElementById('questionNumber').textContent = `Question ${index + 1}`;
        
    //     // Display the question based on type
    //     if (questionType === "mcq") {
    //         displayMCQQuestion(question, index);
    //     } else {
    //         displayCodingQuestion(question, index);
    //     }
        
    //     // Update the question navigation UI
    //     updateQuestionNavigation(index);
    // }
function loadQuestion(index) {
    console.log(`Loading question at index: ${index}`); // Debug log
    
    const examData = JSON.parse(localStorage.getItem('currentExam'));
    if (!examData) {
        console.error('No exam data found');
        return;
    }
    
    let question;
    let questionType;
    let totalQuestions = getTotalQuestions(examData);
    
    // Validate index
    if (index < 0 || index >= totalQuestions) {
        console.error(`Invalid question index: ${index}. Total questions: ${totalQuestions}`);
        return;
    }
    
    // Get the appropriate question based on question type and index
    if (examData.questionType === "mcq") {
        const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions'));
        if (!mcqQuestions || index >= mcqQuestions.length) {
            console.error(`MCQ question not found at index: ${index}`);
            return;
        }
        question = mcqQuestions[index];
        questionType = "mcq";
    } 
    else if (examData.questionType === "coding") {
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
        if (!codingQuestions || index >= codingQuestions.length) {
            console.error(`Coding question not found at index: ${index}`);
            return;
        }
        question = codingQuestions[index];
        questionType = "coding";
    } 
    else if (examData.questionType === "mcq&coding") {
        // For mixed exams, determine if we're showing MCQ or coding based on index
        const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions')) || [];
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions')) || [];
        
        console.log(`Mixed exam: MCQ count: ${mcqQuestions.length}, Coding count: ${codingQuestions.length}, Index: ${index}`); // Debug log
        
        if (index < mcqQuestions.length) {
            question = mcqQuestions[index];
            questionType = "mcq";
        } else {
            const codingIndex = index - mcqQuestions.length;
            if (codingIndex >= codingQuestions.length) {
                console.error(`Coding question not found at adjusted index: ${codingIndex}`);
                return;
            }
            question = codingQuestions[codingIndex];
            questionType = "coding";
        }
    }
    
    if (!question) {
        console.error(`Question not found at index: ${index}`);
        return;
    }
    
    console.log(`Question loaded: ${question._id}, Type: ${questionType}`); // Debug log
    
    // Update the current question index BEFORE displaying the question
    localStorage.setItem('currentQuestionIndex', index.toString());
    
    // Update question number display
    const questionNumberElement = document.getElementById('questionNumber');
    if (questionNumberElement) {
        questionNumberElement.textContent = `Question ${index + 1}`;
    }
    
    // Display the question based on type
    if (questionType === "mcq") {
        displayMCQQuestion(question, index);
    } else {
        displayCodingQuestion(question, index);
    }
    
    // Update the question navigation UI
    updateQuestionNavigation(index);
}

    // Function to display an MCQ question
    function displayMCQQuestion(question, index) {
        const questionContainer = document.getElementById('questionContainer');
        questionContainer.innerHTML = ''; // Clear previous content
        
        // Create question display
        const questionElement = document.createElement('div');
        questionElement.classList.add('mcq-question');
        
        // Add question title and text
        const questionTitle = document.createElement('h2');
        questionTitle.classList.add('question-title');
        questionTitle.textContent = question.questionTitle || question.question;
        questionElement.appendChild(questionTitle);
        

        
        // Add options
        const optionsContainer = document.createElement('div');
        optionsContainer.classList.add('mcq-options');
        
        question.options.forEach((option, i) => {
            const optionDiv = document.createElement('div');
            optionDiv.classList.add('mcq-option');
            
            // Check if this option is already selected
            const isSelected = getSelectedMCQAnswer(question._id, i);
            if (isSelected) {
                optionDiv.classList.add('selected');
            }
            
            // Create radio input
            const radioInput = document.createElement('input');
            radioInput.type = 'radio';
            radioInput.name = `q${index}`;
            radioInput.id = `q${index}opt${i}`;
            radioInput.value = i;
            radioInput.checked = isSelected;
            
            // Create label
            const label = document.createElement('label');
            label.htmlFor = `q${index}opt${i}`;
            label.textContent = option;
            
            // Add event listener to save answer and update UI
            radioInput.addEventListener('change', () => {
                // Save the selected answer
                saveMCQAnswer(question._id, i, option);
                
                // Update the UI
                optionsContainer.querySelectorAll('.mcq-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                optionDiv.classList.add('selected');
                
                // Update progress
                updateProgress();
            });
            
            // Also add click event to the whole option div for better UX
            optionDiv.addEventListener('click', () => {
                radioInput.checked = true;
                
                // Trigger the change event
                const event = new Event('change');
                radioInput.dispatchEvent(event);
            });
            
            // Append elements
            optionDiv.appendChild(radioInput);
            optionDiv.appendChild(label);
            optionsContainer.appendChild(optionDiv);
        });
        
        questionElement.appendChild(optionsContainer);
        questionContainer.appendChild(questionElement);
        
        // Clear any badges from previous questions
        document.getElementById('questionBadges').innerHTML = '';
    }

    // Function to display a coding question
    function displayCodingQuestion(question, index) {
        const questionContainer = document.getElementById('questionContainer');
        questionContainer.innerHTML = ''; // Clear previous content
        
        // Add badges to the question header
        const badgesContainer = document.getElementById('questionBadges');
        badgesContainer.innerHTML = '';
        
        if (question.level) {
            const levelBadge = document.createElement('div');
            levelBadge.className = `badge badge-${question.level}`;
            levelBadge.textContent = question.level.toUpperCase();
            badgesContainer.appendChild(levelBadge);
        }
        
        if (question.classification) {
            const categoryBadge = document.createElement('div');
            categoryBadge.className = 'badge badge-category';
            categoryBadge.textContent = question.classification;
            badgesContainer.appendChild(categoryBadge);
        }
        
        if (question.maxMarks) {
            const marksBadge = document.createElement('div');
            marksBadge.className = 'badge badge-marks';
            marksBadge.textContent = `${question.maxMarks} marks`;
            badgesContainer.appendChild(marksBadge);
        }
        
        // Create question display with additional test case elements
        const questionElement = document.createElement('div');
        questionElement.classList.add('coding-question');
        
        // Add question title
        const questionTitle = document.createElement('h2');
        questionTitle.classList.add('question-title');
        questionTitle.textContent = question.questionTile || `Problem ${index + 1}`;
        questionElement.appendChild(questionTitle);
        
        // Add question description
        const questionDescription = document.createElement('div');
        questionDescription.classList.add('question-description');
        questionDescription.innerHTML = question.questiontext;
        questionElement.appendChild(questionDescription);
        
        // Add input format if available
        if (question.inputFormat) {
            const inputFormatTitle = document.createElement('h3');
            inputFormatTitle.classList.add('section-title');
            inputFormatTitle.innerHTML = '<i class="fas fa-sign-in-alt"></i> Input Format';
            questionElement.appendChild(inputFormatTitle);
            
            const inputFormat = document.createElement('p');
            inputFormat.innerHTML = question.inputFormat;
            questionElement.appendChild(inputFormat);
        }
        
        // Add output format if available
        if (question.outputFormat) {
            const outputFormatTitle = document.createElement('h3');
            outputFormatTitle.classList.add('section-title');
            outputFormatTitle.innerHTML = '<i class="fas fa-sign-out-alt"></i> Output Format';
            questionElement.appendChild(outputFormatTitle);
            
            const outputFormat = document.createElement('p');
            outputFormat.innerHTML = question.outputFormat;
            questionElement.appendChild(outputFormat);
        }
        
        // Add constraints if available
        if (question.constraits) {
            const constraintsTitle = document.createElement('h3');
            constraintsTitle.classList.add('section-title');
            constraintsTitle.innerHTML = '<i class="fas fa-exclamation-circle"></i> Constraints';
            questionElement.appendChild(constraintsTitle);
            
            const constraints = document.createElement('p');
            constraints.innerHTML = question.constraits;
            questionElement.appendChild(constraints);
        }
        
        // Add sample input/output if available
        if (question.sampleInput || question.sampleOutput) {
            const sampleTitle = document.createElement('h3');
            sampleTitle.classList.add('section-title');
            sampleTitle.innerHTML = '<i class="fas fa-vial"></i> Sample Test Case';
            questionElement.appendChild(sampleTitle);
            
            if (question.sampleInput) {
                const sampleInputTitle = document.createElement('h4');
                sampleInputTitle.textContent = 'Sample Input:';
                sampleInputTitle.style.fontWeight = '600';
                sampleInputTitle.style.marginTop = '0.75rem';
                questionElement.appendChild(sampleInputTitle);
                
                const sampleInput = document.createElement('pre');
                sampleInput.textContent = question.sampleInput;
                questionElement.appendChild(sampleInput);
            }
            
            if (question.sampleOutput) {
                const sampleOutputTitle = document.createElement('h4');
                sampleOutputTitle.textContent = 'Sample Output:';
                sampleOutputTitle.style.fontWeight = '600';
                sampleOutputTitle.style.marginTop = '0.75rem';
                questionElement.appendChild(sampleOutputTitle);
                
                const sampleOutput = document.createElement('pre');
                sampleOutput.textContent = question.sampleOutput;
                questionElement.appendChild(sampleOutput);
            }
        }
        
        // Display public test cases if any
        if (question.testCases && question.testCases.filter(tc => tc.isPublic).length > 0) {
            const testCasesTitle = document.createElement('h3');
            testCasesTitle.classList.add('section-title');
            testCasesTitle.innerHTML = '<i class="fas fa-clipboard-check"></i> Public Test Cases';
            questionElement.appendChild(testCasesTitle);
            
            const publicTestCases = question.testCases.filter(tc => tc.isPublic);
            
            publicTestCases.forEach((testCase, tcIndex) => {
                const testCaseTitle = document.createElement('h4');
                testCaseTitle.textContent = `Test Case ${tcIndex + 1}:`;
                testCaseTitle.style.fontWeight = '600';
                testCaseTitle.style.marginTop = '1rem';
                questionElement.appendChild(testCaseTitle);
                
                const testInputTitle = document.createElement('h5');
                testInputTitle.textContent = 'Input:';
                testInputTitle.style.fontWeight = '500';
                testInputTitle.style.marginTop = '0.5rem';
                questionElement.appendChild(testInputTitle);
                
                const testInput = document.createElement('pre');
                testInput.textContent = testCase.input;
                questionElement.appendChild(testInput);
                
                const testOutputTitle = document.createElement('h5');
                testOutputTitle.textContent = 'Expected Output:';
                testOutputTitle.style.fontWeight = '500';
                testOutputTitle.style.marginTop = '0.5rem';
                questionElement.appendChild(testOutputTitle);
                
                const testOutput = document.createElement('pre');
                testOutput.textContent = testCase.expectedOutput;
                questionElement.appendChild(testOutput);
            });
        }
        
        // Add code editor section
        const editorSection = document.createElement('div');
        editorSection.classList.add('editor-section');
        
        const editorTitle = document.createElement('h3');
        editorTitle.classList.add('section-title');
        editorTitle.innerHTML = '<i class="fas fa-code"></i> Your Solution';
        editorSection.appendChild(editorTitle);
        
        // Language selector
   const languageSelector = document.createElement('div');
    languageSelector.classList.add('language-selector');
    
    const languageLabel = document.createElement('label');
    languageLabel.htmlFor = `language-select-${question._id}`;
    languageLabel.textContent = 'Select Language:';
    languageSelector.appendChild(languageLabel);
    
    const languageSelect = document.createElement('select');
    languageSelect.id = `language-select-${question._id}`;
    languageSelect.classList.add('language-select');
    
    const languages = [
        { id: '71', name: 'Python (3.10.0)' },
        { id: '62', name: 'Java (OpenJDK 17)' },
        { id: '54', name: 'C++ (GCC 11.2.0)' },
        { id: '63', name: 'JavaScript (Node.js 16.13.0)' },
        { id: '51', name: 'C# (Mono 6.12.0)' },
        { id: '50', name: 'C (GCC 11.2.0)' }
    ];
    
    // Get the previously selected language for this question
    const selectedLanguageId = getSelectedLanguageForQuestion(question._id);
    
    languages.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang.id;
        option.textContent = lang.name;
        if (lang.id === selectedLanguageId) {
            option.selected = true;
        }
        languageSelect.appendChild(option);
    });
    
    // Set the previous language tracker
    languageSelect.dataset.previousLanguage = selectedLanguageId;
    
    languageSelector.appendChild(languageSelect);
    editorSection.appendChild(languageSelector);
    
    // Code editor with proper initialization
    const codeEditorContainer = document.createElement('div');
    codeEditorContainer.classList.add('code-editor');
    
    const codeTextarea = document.createElement('textarea');
    codeTextarea.id = `codeEditor-${question._id}`;
    codeTextarea.classList.add('code-textarea');
    codeTextarea.spellcheck = false;
    
    // Load saved code for the selected language or use starter code
    const savedCode = getCodeForLanguage(question._id, selectedLanguageId);
    if (savedCode && savedCode.trim() !== '') {
        codeTextarea.value = savedCode;
    } else {
        codeTextarea.value = getStarterCode(question, selectedLanguageId);
    }
    
    codeEditorContainer.appendChild(codeTextarea);
    editorSection.appendChild(codeEditorContainer);
        // Editor buttons
           const editorButtons = document.createElement('div');
    editorButtons.classList.add('editor-buttons');
    
    const runCodeBtn = document.createElement('button');
    runCodeBtn.classList.add('btn', 'btn-primary');
    runCodeBtn.dataset.questionId = question._id;
    runCodeBtn.innerHTML = '<i class="fas fa-play"></i> Run Code';
    editorButtons.appendChild(runCodeBtn);
    
    const runCustomBtn = document.createElement('button');
    runCustomBtn.classList.add('btn', 'btn-secondary', 'run-custom-btn'); // Added a class for easier selection
    runCustomBtn.dataset.questionId = question._id;
    runCustomBtn.innerHTML = '<i class="fas fa-keyboard"></i> Custom Input';
    editorButtons.appendChild(runCustomBtn);
    
    const runAllTestsBtn = document.createElement('button');
    runAllTestsBtn.classList.add('btn', 'btn-secondary', 'run-all-tests-btn'); // Added a class for easier selection
    runAllTestsBtn.dataset.questionId = question._id;
    runAllTestsBtn.innerHTML = '<i class="fas fa-vials"></i> Run All Tests';
    editorButtons.appendChild(runAllTestsBtn);
        
        editorSection.appendChild(editorButtons);
        questionElement.appendChild(editorSection);
        
        // Custom test input section (hidden by default)
        const customTestSection = document.createElement('div');
        customTestSection.classList.add('custom-test-section');
        customTestSection.id = `custom-test-${question._id}`;
        customTestSection.style.display = 'none';
        
        const customTestTitle = document.createElement('h3');
        customTestTitle.classList.add('section-title');
        customTestTitle.innerHTML = '<i class="fas fa-keyboard"></i> Custom Test Input';
        customTestSection.appendChild(customTestTitle);
        
        const customInputLabel = document.createElement('p');
        customInputLabel.textContent = 'Enter your test input:';
        customTestSection.appendChild(customInputLabel);
        
        const customInputTextarea = document.createElement('textarea');
        customInputTextarea.id = `custom-input-${question._id}`;
        customInputTextarea.classList.add('custom-input-textarea');
        customInputTextarea.placeholder = 'Enter your test input here...';
        customTestSection.appendChild(customInputTextarea);
        
        const runCustomInputBtn = document.createElement('button');
        runCustomInputBtn.id = `run-custom-input-${question._id}`;
        runCustomInputBtn.classList.add('btn', 'btn-primary');
        runCustomInputBtn.innerHTML = '<i class="fas fa-play"></i> Run With Custom Input';
        customTestSection.appendChild(runCustomInputBtn);
        
        questionElement.appendChild(customTestSection);
        
        // Results section (hidden by default)
        const resultsSection = document.createElement('div');
        resultsSection.classList.add('results-section');
        resultsSection.id = `results-${question._id}`;
        resultsSection.style.display = 'none';
        
        const resultsTitle = document.createElement('h3');
        resultsTitle.classList.add('section-title');
        resultsTitle.innerHTML = '<i class="fas fa-clipboard-list"></i> Results';
        resultsSection.appendChild(resultsTitle);
        
        const resultOutput = document.createElement('div');
        resultOutput.id = `result-output-${question._id}`;
        resultOutput.classList.add('result-output');
        resultsSection.appendChild(resultOutput);
        
        const testResultsSection = document.createElement('div');
        testResultsSection.id = `test-results-${question._id}`;
        testResultsSection.classList.add('test-results');
        testResultsSection.style.display = 'none';
        
        const testResultsTitle = document.createElement('h4');
        testResultsTitle.classList.add('section-title');
        testResultsTitle.innerHTML = '<i class="fas fa-tasks"></i> Test Case Results';
        testResultsSection.appendChild(testResultsTitle);
        
        const testResultsTable = document.createElement('table');
        testResultsTable.classList.add('test-results-table');
        
        const tableHead = document.createElement('thead');
        tableHead.innerHTML = `
            <tr>
                <th>Test Case</th>
                <th>Status</th>
                <th>Time</th>
                <th>Memory</th>
                <th>Details</th>
            </tr>
        `;
        testResultsTable.appendChild(tableHead);
        
        const tableBody = document.createElement('tbody');
        tableBody.id = `test-results-body-${question._id}`;
        testResultsTable.appendChild(tableBody);
        
        testResultsSection.appendChild(testResultsTable);
        resultsSection.appendChild(testResultsSection);
        
        questionElement.appendChild(resultsSection);
        
        // Append the complete question element to the container
        questionContainer.appendChild(questionElement);
        
        // Add event listeners for code editor features
        setupCodeEditor(question._id);
        
        // Add event listeners for code execution buttons
        setupCodeExecutionButtons(question._id);
        
        // Add event listener for language selection to update the starter code
        const langSelect = document.getElementById(`language-select-${question._id}`);
    languageSelect.addEventListener('change', () => {
        const selectedLanguage = languageSelect.value;
        const codeEditor = document.getElementById(`codeEditor-${question._id}`);
        const currentCode = codeEditor.value;
        
        // Save current code for the previously selected language
        const previousLanguage = languageSelect.dataset.previousLanguage || '71';
        saveCodeForLanguage(question._id, previousLanguage, currentCode);
        
        // Load code for the newly selected language
        const savedCodeForNewLang = getCodeForLanguage(question._id, selectedLanguage);
        
        if (savedCodeForNewLang && savedCodeForNewLang.trim() !== '') {
            // Use saved code if it exists and is not empty
            codeEditor.value = savedCodeForNewLang;
        } else {
            // Use starter code for the new language
            codeEditor.value = getStarterCode(question, selectedLanguage);
        }
        
        // Update the previous language tracker
        languageSelect.dataset.previousLanguage = selectedLanguage;
        
        // Save the new code and language selection
        saveCodeForLanguage(question._id, selectedLanguage, codeEditor.value);
    });


function saveCodeForLanguage(questionId, languageId, code) {
    const answers = JSON.parse(localStorage.getItem('examAnswers')) || { mcq: {}, coding: {} };
    
    if (!answers.codingByLanguage) {
        answers.codingByLanguage = {};
    }
    
    if (!answers.codingByLanguage[questionId]) {
        answers.codingByLanguage[questionId] = {};
    }
    
    // Save code for specific language
    answers.codingByLanguage[questionId][languageId] = code;
    
    // Also save the currently selected language
    answers.codingByLanguage[questionId].selectedLanguage = languageId;
    
    localStorage.setItem('examAnswers', JSON.stringify(answers));
}
function getCodeForLanguage(questionId, languageId) {
    const answers = JSON.parse(localStorage.getItem('examAnswers'));
    
    if (answers && 
        answers.codingByLanguage && 
        answers.codingByLanguage[questionId] && 
        answers.codingByLanguage[questionId][languageId]) {
        return answers.codingByLanguage[questionId][languageId];
    }
    
    return null;
}
    // Function to set up code editor
    function setupCodeEditor(questionId) {
        const codeEditor = document.getElementById(`codeEditor-${questionId}`);
        
        // Add event listener to save code when typing
        codeEditor.addEventListener('input', () => {
            // Debounce to avoid saving too frequently
            clearTimeout(codeEditor.saveTimeout);
            codeEditor.saveTimeout = setTimeout(() => {
                saveCodingAnswer(questionId, codeEditor.value);
                updateProgress();
            }, 1000);
        });
        
        // Add tab key support
        codeEditor.addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = this.selectionStart;
                const end = this.selectionEnd;
                
                // Insert tab at the cursor position
                this.value = this.value.substring(0, start) + '    ' + this.value.substring(end);
                
                // Move the cursor position after the tab
                this.selectionStart = this.selectionEnd = start + 4;
            }
        });
    }

    // Function to set up code execution buttons
    function setupCodeExecutionButtons(questionId) {
        // Run code button
        const runCodeBtn = document.querySelector(`.btn-primary[data-question-id="${questionId}"]`);
        if (runCodeBtn) {
            runCodeBtn.addEventListener('click', () => runCode(questionId));
        }
        
        // Run custom test button
   const runCustomBtn = document.querySelector(`.run-custom-btn[data-question-id="${questionId}"]`);
    if (runCustomBtn) {
        runCustomBtn.addEventListener('click', () => {
            const customTestSection = document.getElementById(`custom-test-${questionId}`);
            // Toggle the display
            if (customTestSection.style.display === 'none') {
                customTestSection.style.display = 'block';
            } else {
                customTestSection.style.display = 'none';
            }
        });
    }
        
        // Run with custom input button
           const runCustomInputBtn = document.getElementById(`run-custom-input-${questionId}`);
    if (runCustomInputBtn) {
        runCustomInputBtn.addEventListener('click', () => runCodeWithCustomInput(questionId));
    }
    
    // Run all tests button - FIXED
    const runAllTestsBtn = document.querySelector(`.run-all-tests-btn[data-question-id="${questionId}"]`);
    if (runAllTestsBtn) {
        runAllTestsBtn.addEventListener('click', () => runAllTests(questionId));
    }
    }

    // Helper function to get starter code for a language
    function getStarterCode(question, languageId) {
        if (!question.starterCode || question.starterCode.length === 0) {
            return question.solutionTemplate || '';
        }
        
        // Find the starter code for the selected language
        const starter = question.starterCode.find(code => code.language === getLanguageName(languageId));
        
        // If found, return that code, otherwise return the first available or template
        return starter ? starter.code : (question.starterCode[0].code || question.solutionTemplate || '');
    }

    // Helper function to check if current code is a starter code
    function isStarterCode(code, question, languageId) {
        if (!question || !question.starterCode) return false;
        
        // First check - is the code the starter code for the CURRENT language?
        if (languageId) {
            const currentLanguageName = getLanguageName(languageId);
            const starterForCurrentLanguage = question.starterCode.find(
                starter => starter.language === currentLanguageName
            );
            
            if (starterForCurrentLanguage && starterForCurrentLanguage.code === code) {
                return true;
            }
        }
        
        // Second check - is the code ANY starter code from ANY language?
        return question.starterCode.some(starter => starter.code === code);
    }

    // Helper function to convert languageId to language name
    function getLanguageName(languageId) {
        const languageMap = {
            '62': 'java',
            '71': 'python',
            '54': 'cpp',
            '63': 'javascript',
            '51': 'csharp',
            '50': 'c'
        };
        
        return languageMap[languageId] || 'python';
    }

    // Function to save MCQ answer to localStorage
    function saveMCQAnswer(questionId, optionIndex, optionText) {
        const answers = JSON.parse(localStorage.getItem('examAnswers')) || { mcq: {}, coding: {} };
        if (!answers.mcq) {
            answers.mcq = {};
        }
        answers.mcq[questionId] = {
            index: optionIndex,
            value: optionText
        };
        localStorage.setItem('examAnswers', JSON.stringify(answers));
        
        // Mark the question as answered in navigation
        updateQuestionNavigation();
    }

    // Function to get selected MCQ answer
    function getSelectedMCQAnswer(questionId, optionIndex) {
        const answers = JSON.parse(localStorage.getItem('examAnswers'));
        return answers && 
               answers.mcq && 
               answers.mcq[questionId] && 
               answers.mcq[questionId].index === optionIndex;
    }

    // Function to save coding answer to localStorage
    function saveCodingAnswer(questionId, code) {
        const answers = JSON.parse(localStorage.getItem('examAnswers'));
        if (!answers.coding) {
            answers.coding = {};
        }
        answers.coding[questionId] = code;
        localStorage.setItem('examAnswers', JSON.stringify(answers));
        
        // Mark the question as answered in navigation
        updateQuestionNavigation();
    }

    // Function to get saved coding answer
    function getSavedCodingAnswer(questionId) {
        const answers = JSON.parse(localStorage.getItem('examAnswers'));
        return answers && answers.coding && answers.coding[questionId] ? answers.coding[questionId] : '';
    }

    // Function to check for unanswered questions
    function checkUnansweredQuestions() {
        const examData = JSON.parse(localStorage.getItem('currentExam'));
        const answers = JSON.parse(localStorage.getItem('examAnswers'));
        
        // Initialize arrays to store question IDs
        let mcqQuestionIds = [];
        let codingQuestionIds = [];
        
        // Get all question IDs based on the exam type
        if (examData.questionType === "mcq" || examData.questionType === "mcq&coding") {
            const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions'));
            mcqQuestionIds = mcqQuestions.map(q => q._id);
        }
        
        if (examData.questionType === "coding" || examData.questionType === "mcq&coding") {
            const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
            codingQuestionIds = codingQuestions.map(q => q._id);
        }
        
        // Check which questions have been answered
        const answeredMcqIds = answers.mcq ? Object.keys(answers.mcq) : [];
        const answeredCodingIds = answers.coding ? Object.keys(answers.coding) : [];
        
        // Find unanswered questions
        const unansweredMcqIds = mcqQuestionIds.filter(id => !answeredMcqIds.includes(id));
        const unansweredCodingIds = codingQuestionIds.filter(id => !answeredCodingIds.includes(id));
        
        // Mark unanswered questions in the navigation
        const navButtons = document.querySelectorAll('.nav-button');
        navButtons.forEach(button => {
            const index = parseInt(button.dataset.index);
            let isUnanswered = false;
            
            // Check if this is an unanswered MCQ question
            if (index < mcqQuestionIds.length && unansweredMcqIds.includes(mcqQuestionIds[index])) {
                isUnanswered = true;
            }
            
            // Check if this is an unanswered coding question
            if (examData.questionType === "mcq&coding" && index >= mcqQuestionIds.length) {
                const codingIndex = index - mcqQuestionIds.length;
                if (codingIndex < codingQuestionIds.length && 
                    unansweredCodingIds.includes(codingQuestionIds[codingIndex])) {
                    isUnanswered = true;
                }
            } else if (examData.questionType === "coding") {
                if (unansweredCodingIds.includes(codingQuestionIds[index])) {
                    isUnanswered = true;
                }
            }
            
            // Mark unanswered questions with a red border
            if (isUnanswered) {
                button.classList.add('unanswered');
            } else {
                button.classList.remove('unanswered');
            }
        });
        
        return {
            unansweredMcq: unansweredMcqIds.length,
            unansweredCoding: unansweredCodingIds.length,
            total: unansweredMcqIds.length + unansweredCodingIds.length
        };
    }

    // Function to setup question navigation
    // function setupQuestionNavigation() {
    //     const examData = JSON.parse(localStorage.getItem('currentExam'));
    //     const navigationContainer = document.getElementById('questionNavigation');
        
    //     // Clear previous navigation
    //     navigationContainer.innerHTML = '';
        
    //     // Determine total questions
    //     let totalQuestions = getTotalQuestions(examData);
        
    //     // Create navigation buttons
    //     for (let i = 0; i < totalQuestions; i++) {
    //         const navButton = document.createElement('button');
    //         navButton.textContent = i + 1;
    //         navButton.classList.add('nav-button');
    //         navButton.dataset.index = i;
    //         navButton.addEventListener('click', () => {
    //             loadQuestion(i);
    //         });
    //         navigationContainer.appendChild(navButton);
    //     }
        
    //     // Set up next/prev buttons
    //     const prevButton = document.getElementById('prevQuestion');
    //     const nextButton = document.getElementById('nextQuestion');
        
    //     prevButton.addEventListener('click', () => {
    //         const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex'));
    //         if (currentIndex > 0) {
    //             loadQuestion(currentIndex - 1);
    //         }
    //     });
        
    //     nextButton.addEventListener('click', () => {
    //         const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex'));
    //         if (currentIndex < totalQuestions - 1) {
    //             loadQuestion(currentIndex + 1);
    //         }
    //     });
        
    //     // Set up the submit button
    //     const submitButton = document.getElementById('submitExam');
    //     submitButton.addEventListener('click', confirmSubmitExam);
        
    //     // Check for unanswered questions
    //     checkUnansweredQuestions();
    // }
function getSelectedLanguageForQuestion(questionId) {
    const answers = JSON.parse(localStorage.getItem('examAnswers'));
    
    if (answers && 
        answers.codingByLanguage && 
        answers.codingByLanguage[questionId] && 
        answers.codingByLanguage[questionId].selectedLanguage) {
        return answers.codingByLanguage[questionId].selectedLanguage;
    }
    
    return '71'; // Default to Python
}
    function setupQuestionNavigation() {
    const examData = JSON.parse(localStorage.getItem('currentExam'));
    const navigationContainer = document.getElementById('questionNavigation');
    
    // Clear previous navigation
    navigationContainer.innerHTML = '';
    
    // Determine total questions
    let totalQuestions = getTotalQuestions(examData);
    
    // Create navigation buttons
    for (let i = 0; i < totalQuestions; i++) {
        const navButton = document.createElement('button');
        navButton.textContent = i + 1;
        navButton.classList.add('nav-button');
        navButton.dataset.index = i;
        navButton.addEventListener('click', () => {
            console.log(`Navigation button clicked: ${i}`); // Debug log
            loadQuestion(i);
        });
        navigationContainer.appendChild(navButton);
    }
    
    // Set up next/prev buttons with better error handling
    const prevButton = document.getElementById('prevQuestion');
    const nextButton = document.getElementById('nextQuestion');
    
    // Remove any existing event listeners
    if (prevButton) {
        const newPrevButton = prevButton.cloneNode(true);
        prevButton.parentNode.replaceChild(newPrevButton, prevButton);
        
        newPrevButton.addEventListener('click', () => {
            const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
            console.log(`Previous button clicked. Current index: ${currentIndex}`); // Debug log
            if (currentIndex > 0) {
                loadQuestion(currentIndex - 1);
            }
        });
    }
    
    if (nextButton) {
        const newNextButton = nextButton.cloneNode(true);
        nextButton.parentNode.replaceChild(newNextButton, nextButton);
        
        newNextButton.addEventListener('click', () => {
            const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
            console.log(`Next button clicked. Current index: ${currentIndex}, Total: ${totalQuestions}`); // Debug log
            if (currentIndex < totalQuestions - 1) {
                loadQuestion(currentIndex + 1);
            }
        });
    }
    
    // Set up the submit button
    const submitButton = document.getElementById('submitExam');
    if (submitButton) {
        // Remove existing listener and add new one
        const newSubmitButton = submitButton.cloneNode(true);
        submitButton.parentNode.replaceChild(newSubmitButton, submitButton);
        newSubmitButton.addEventListener('click', confirmSubmitExam);
    }
    
    // Check for unanswered questions
    checkUnansweredQuestions();
}
    // Function to update question navigation UI
    // function updateQuestionNavigation(currentIndex) {
    //     // If currentIndex is not provided, get it from localStorage
    //     if (currentIndex === undefined) {
    //         currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
    //     }
        
    //     const navButtons = document.querySelectorAll('.nav-button');
    //     navButtons.forEach(button => {
    //         button.classList.remove('active');
    //         if (parseInt(button.dataset.index) === currentIndex) {
    //             button.classList.add('active');
    //         }
    //     });
        
    //     // Update next/prev button states
    //     const examData = JSON.parse(localStorage.getItem('currentExam'));
    //     let totalQuestions = getTotalQuestions(examData);
        
    //     const prevButton = document.getElementById('prevQuestion');
    //     const nextButton = document.getElementById('nextQuestion');
        
    //     if (prevButton) {
    //         prevButton.disabled = currentIndex === 0;
    //     }
        
    //     if (nextButton) {
    //         nextButton.disabled = currentIndex === totalQuestions - 1;
    //     }
        
    //     // Check for unanswered questions
    //     checkUnansweredQuestions();
    // }
function updateQuestionNavigation(currentIndex) {
    // If currentIndex is not provided, get it from localStorage
    if (currentIndex === undefined) {
        currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
    }
    
    console.log(`Updating navigation for index: ${currentIndex}`); // Debug log
    
    const navButtons = document.querySelectorAll('.nav-button');
    navButtons.forEach((button, buttonIndex) => {
        button.classList.remove('active');
        if (buttonIndex === currentIndex) {
            button.classList.add('active');
        }
    });
    
    // Update next/prev button states
    const examData = JSON.parse(localStorage.getItem('currentExam'));
    let totalQuestions = getTotalQuestions(examData);
    
    const prevButton = document.getElementById('prevQuestion');
    const nextButton = document.getElementById('nextQuestion');
    
    if (prevButton) {
        prevButton.disabled = currentIndex === 0;
    }
    
    if (nextButton) {
        nextButton.disabled = currentIndex === totalQuestions - 1;
    }
    
    // Check for unanswered questions
    checkUnansweredQuestions();
}

    // Function to start exam timer
    function startExamTimer() {
        const endTimeStr = localStorage.getItem('examEndTime');
        if (!endTimeStr) return;
        
        const endTime = parseInt(endTimeStr);
        const timerDisplay = document.getElementById('examTimer');
        
        const timer = setInterval(() => {
            const now = new Date().getTime();
            const timeLeft = endTime - now;
            
            if (timeLeft <= 0) {
                clearInterval(timer);
                timerDisplay.innerHTML = '<i class="fas fa-clock"></i> Time\'s up!';
                timerDisplay.classList.add('timer-critical');
                submitExam(); // Auto-submit when time's up
                return;
            }
            
            // Calculate time left
            const hours = Math.floor(timeLeft / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
            
            // Format time and update display
            timerDisplay.innerHTML = `<i class="fas fa-clock"></i> ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Add warning class when less than 5 minutes left
            if (timeLeft < 5 * 60 * 1000) {
                timerDisplay.classList.add('timer-critical');
            }
        }, 1000);
    }

    // Function to submit exam
    function submitExam() {
        const examData = JSON.parse(localStorage.getItem('currentExam'));
        const answers = JSON.parse(localStorage.getItem('examAnswers'));
        
        // Show loading indicator
        const submitButton = document.getElementById('submitExam');
        const originalButtonText = submitButton.innerHTML;
        submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';
        submitButton.disabled = true;
        
        // Prepare submission data according to Mongoose schema format
        const submissionData = {
            exam: examData._id,
            mcqAnswers: [],
            codingAnswers: []
        };
        
        // Process MCQ answers
        if (answers.mcq && Object.keys(answers.mcq).length > 0) {
            for (const questionId in answers.mcq) {
                const answerData = answers.mcq[questionId];
                
                // Send the actual option text (value) instead of just the index
                submissionData.mcqAnswers.push({
                    questionId: questionId,
                    selectedOption: answerData.value || answerData.index.toString()
                });
            }
        }
        
        // Process coding answers
          if (answers.codingByLanguage && Object.keys(answers.codingByLanguage).length > 0) {
        for (const questionId in answers.codingByLanguage) {
            const questionData = answers.codingByLanguage[questionId];
            const selectedLanguage = questionData.selectedLanguage || '71';
            const codeForSelectedLanguage = questionData[selectedLanguage];
            
            if (codeForSelectedLanguage && codeForSelectedLanguage.trim() !== '') {
                submissionData.codingAnswers.push({
                    questionId: questionId,
                    code: codeForSelectedLanguage,
                    language: parseInt(selectedLanguage)
                });
            }
        }
    }
           const userId = document.getElementById('user').textContent;
    const examId = document.getElementById('exam').textContent;
            const integrity = examIntegrity.init({
        // Required exam information
        examId: examId,
        userId: userId,
        
        // Optional: Custom API endpoints
        apiEndpoints: {
            integrityUpdate: '/update-integrity',
            activityPing: '/dashboard/see-active',
            saveImage: '/save-image'
        },
        
        // Optional: Custom behavior configuration
        config: {
            maxViolations: 5,                // Default: 3
            maxRefreshes: 3,                 // Default: 2
            pingInterval: 30000,             // Default: 20000 (20 seconds)
            webcamCaptureInterval: 10000     // Default: 5000 (5 seconds)
        },
        
        // Optional: Callback when violations trigger auto-submit
        onAutoSubmit: function(reason) {
            console.log(`Auto-submitting exam due to: ${reason}`);
            
            // Your custom submit logic
            document.getElementById('examForm').submit();
            
            // Optional: Redirect after submission
            setTimeout(() => {
                window.location.href = '/exam-complete';
            }, 1000);
        },
        
        // Optional: Start webcam automatically on init
        startWebcam: false
    });
    
                const violations = integrity.getViolationCounts();
        console.log('Final violation counts:', violations);
        
        // Stop integrity monitoring
        integrity.stop();
        
        console.log('Submission data:', submissionData);
        
        // Send submission to server using fetch API with JSON
        fetch('/dashboard/submit-test', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(submissionData)
        })
        .then(response => {
            if (!response.ok) {
                if (response.redirected) {
                    window.location.href = response.url;
                    return;
                }
                return response.text().then(text => {
                    throw new Error(text || 'Submission failed');
                });
            }
            return response.json();
        })
        .then(data => {
            showSuccessMessage('Exam submitted successfully!');
            
            // Clear exam data from localStorage
            clearExamData();
            
            // Redirect to dashboard or results page after a short delay
            setTimeout(() => {
                window.close();
            }, 1500);
        })
        .catch(error => {
            console.error('Error submitting exam:', error);
            showErrorMessage(`There was an error submitting your exam: ${error.message}`);
            
            // Reset button state
            submitButton.innerHTML = originalButtonText;
            submitButton.disabled = false;
        });
    }

    // Function to show success message
    function showSuccessMessage(message) {
        const messageContainer = document.createElement('div');
        messageContainer.className = 'message-container success-message';
        messageContainer.innerHTML = `
            <div class="message-content">
                <i class="fas fa-check-circle"></i>
                <span>${message}</span>
            </div>
        `;
        document.body.appendChild(messageContainer);
        
        setTimeout(() => {
            messageContainer.classList.add('show');
        }, 10);
        
        setTimeout(() => {
            messageContainer.classList.remove('show');
            setTimeout(() => {
                document.body.removeChild(messageContainer);
            }, 500);
        }, 3000);
    }

    // Function to show error message
    function showErrorMessage(message) {
        const messageContainer = document.createElement('div');
        messageContainer.className = 'message-container error-message';
        messageContainer.innerHTML = `
            <div class="message-content">
                <i class="fas fa-exclamation-circle"></i>
                <span>${message}</span>
            </div>
        `;
        document.body.appendChild(messageContainer);
        
        setTimeout(() => {
            messageContainer.classList.add('show');
        }, 10);
        
        setTimeout(() => {
            messageContainer.classList.remove('show');
            setTimeout(() => {
                document.body.removeChild(messageContainer);
            }, 500);
        }, 5000);
    }

    // Helper function to clear exam data
function clearExamData() {
    localStorage.removeItem('currentExam');
    localStorage.removeItem('mcqQuestions');
    localStorage.removeItem('codingQuestions');
    localStorage.removeItem('currentQuestionIndex');
    localStorage.removeItem('examEndTime');
    localStorage.removeItem('examAnswers');
}

    // Function to confirm submission
    function confirmSubmitExam() {
        // Check if all questions have been attempted
        const unansweredStatus = checkUnansweredQuestions();
        
        // Create a custom confirmation modal
        const modalContainer = document.createElement('div');
        modalContainer.className = 'modal-container';
        
        let confirmMessage = '<h3>Submit Exam?</h3>';
        
        if (unansweredStatus.total > 0) {
            confirmMessage += `
                <p class="warning"><i class="fas fa-exclamation-triangle"></i> You have ${unansweredStatus.total} unanswered question(s).</p>
                <p>Are you sure you want to submit your exam?</p>
            `;
        } else {
            confirmMessage += `
                <p>You have answered all questions. Are you ready to submit your exam?</p>
            `;
        }
        
        modalContainer.innerHTML = `
            <div class="modal-backdrop"></div>
            <div class="modal-content">
                <div class="modal-header">
                    <span class="modal-close">&times;</span>
                </div>
                <div class="modal-body">
                    ${confirmMessage}
                </div>
                <div class="modal-footer">
                    <button id="modal-cancel" class="btn btn-secondary">Cancel</button>
                    <button id="modal-confirm" class="btn btn-danger">Yes, Submit</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modalContainer);
        
        // Add event listeners
        document.querySelector('.modal-close').addEventListener('click', () => {
            document.body.removeChild(modalContainer);
        });
        
        document.querySelector('.modal-backdrop').addEventListener('click', () => {
            document.body.removeChild(modalContainer);
        });
        
        document.getElementById('modal-cancel').addEventListener('click', () => {
            document.body.removeChild(modalContainer);
        });
        
        document.getElementById('modal-confirm').addEventListener('click', () => {
            document.body.removeChild(modalContainer);
            submitExam();
        });
    }

    // Judge0 API Functions

    // Function to create a submission in Judge0
    async function createSubmission(languageId, sourceCode, stdin) {
        try {
            const response = await fetch(`${JUDGE0_API_URL}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    source_code: sourceCode,
                    language_id: languageId,
                    stdin: stdin,
                    expected_output: null,
                    cpu_time_limit: 2,
                    memory_limit: 128000,
                    stack_limit: 64000,
                    max_processes_and_or_threads: 60,
                    enable_network: false
                })
            });
            
            const data = await response.json();
            return data.token;
        } catch (error) {
            console.error('Error creating submission:', error);
            throw error;
        }
    }
    
    // Function to get submission result from Judge0
    async function getSubmissionResult(token) {
        try {
            const response = await fetch(`${JUDGE0_API_URL}/${token}?fields=stdout,stderr,status,time,memory,compile_output,message,exit_code`);
            return await response.json();
        } catch (error) {
            console.error('Error getting submission result:', error);
            throw error;
        }
    }
    
    // Function to poll for submission result
    async function pollSubmissionResult(token) {
        let result = null;
        let attempts = 0;
        const maxAttempts = 30; // Maximum number of polling attempts
        
        while (attempts < maxAttempts) {
            result = await getSubmissionResult(token);
            
            if (result.status.id >= 3) { // Status ID 3 means the submission has finished processing
                return result;
            }
            
            // Wait for 1 second before polling again
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;
        }
        
        throw new Error('Timed out waiting for submission result');
    }
    
    // Function to format output from Judge0
    function formatOutput(result) {
        if (result.status.id === 3) { // Accepted
            return {
                success: true,
                output: result.stdout || '(No output)',
                executionTime: result.time,
                memory: result.memory
            };
        } else if (result.status.id === 4) { // Wrong Answer
            return {
                success: false,
                output: result.stdout || '(No output)',
                executionTime: result.time,
                memory: result.memory
            };
        } else if (result.status.id === 5) { // Time Limit Exceeded
            return {
                success: false,
                output: 'Time Limit Exceeded',
                executionTime: result.time,
                memory: result.memory
            };
        } else if (result.status.id === 6) { // Compilation Error
            return {
                success: false,
                output: result.compile_output || 'Compilation Error',
                executionTime: 0,
                memory: 0
            };
        } else if (result.status.id === 7) { // Runtime Error (SIGSEGV)
            return {
                success: false,
                output: result.stderr || 'Runtime Error',
                executionTime: result.time,
                memory: result.memory
            };
        } else {
            return {
                success: false,
                output: result.stderr || result.message || 'Unknown Error',
                executionTime: result.time || 0,
                memory: result.memory || 0
            };
        }
    }
    
    // Function to compare expected output with actual output
    function compareOutputs(expected, actual) {
        // Normalize line endings and trim whitespace
        expected = expected.replace(/\r\n/g, '\n').trim();
        actual = actual.replace(/\r\n/g, '\n').trim();
        
        return expected === actual;
    }
    
    // Function to display pretty diff between expected and actual output
    function displayDiff(expected, actual) {
        const diff = document.createElement('div');
        diff.className = 'diff-view';
        
        const expectedDiv = document.createElement('div');
        expectedDiv.className = 'diff-expected';
        expectedDiv.innerHTML = `<h4>Expected Output:</h4><pre>${escapeHtml(expected)}</pre>`;
        
        const actualDiv = document.createElement('div');
        actualDiv.className = 'diff-actual';
        actualDiv.innerHTML = `<h4>Your Output:</h4><pre>${escapeHtml(actual)}</pre>`;
        
        diff.appendChild(expectedDiv);
        diff.appendChild(actualDiv);
        
        return diff;
    }

    // Helper function to escape HTML for safe display
    function escapeHtml(string) {
        return string
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    // Function to run code with sample input
    async function runCode(questionId) {
        const codeTextarea = document.getElementById(`codeEditor-${questionId}`);
        const languageSelect = document.getElementById(`language-select-${questionId}`);
        const resultsSection = document.getElementById(`results-${questionId}`);
        const resultOutput = document.getElementById(`result-output-${questionId}`);
        
        const code = codeTextarea.value;
        const languageId = languageSelect.value;
        
        // Get the appropriate question data
        const examData = JSON.parse(localStorage.getItem('currentExam'));
        let question;
        
        if (examData.questionType === "coding") {
            const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
            question = codingQuestions.find(q => q._id == questionId);
        } else if (examData.questionType === "mcq&coding") {
            const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
            question = codingQuestions.find(q => q._id == questionId);
        }
        
        if (!question) {
            console.error('Question not found');
            return;
        }
        
        const sampleInput = question.sampleInput || '';
        
        // Show loading message
        resultOutput.innerHTML = '<div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Running your code...</div>';
        resultsSection.style.display = 'block';
        
        try {
            // Create submission
            const token = await createSubmission(languageId, code, sampleInput);
            
            // Poll for result
            const result = await pollSubmissionResult(token);
            
            // Format and display result
            const formattedResult = formatOutput(result);
            
            let outputHtml = `<h4 class="section-title"><i class="fas fa-terminal"></i> Execution Result:</h4>
                <pre class="execution-output">${escapeHtml(formattedResult.output)}</pre>
                <div class="execution-details">
                    <p><i class="fas fa-clock"></i> Execution Time: ${formattedResult.executionTime}s</p>
                    <p><i class="fas fa-memory"></i> Memory Used: ${Math.round(formattedResult.memory / 1000)}KB</p>
                </div>`;
            
            // Compare with expected output if available
            if (question.sampleOutput) {
                const isCorrect = compareOutputs(question.sampleOutput, formattedResult.output);
                
                outputHtml += `<div class="comparison-result">
                    <p>Sample Test: <span class="${isCorrect ? 'result-pass' : 'result-fail'}">
                        <i class="fas fa-${isCorrect ? 'check' : 'times'}-circle"></i> 
                        ${isCorrect ? 'PASSED' : 'FAILED'}
                    </span></p>
                </div>`;
                
                if (!isCorrect) {
                    outputHtml += '<div id="diff-container-' + questionId + '"></div>';
                }
            }
            
            resultOutput.innerHTML = outputHtml;
            
            // Add diff view if test failed
            if (question.sampleOutput && !compareOutputs(question.sampleOutput, formattedResult.output)) {
                const diffContainer = document.getElementById(`diff-container-${questionId}`);
                diffContainer.appendChild(displayDiff(question.sampleOutput, formattedResult.output));
            }
            
        } catch (error) {
            resultOutput.innerHTML = `<p class="error"><i class="fas fa-exclamation-circle"></i> Error: ${error.message}</p>`;
        }
    }

    // Function to run code with custom input
    async function runCodeWithCustomInput(questionId) {
        const codeTextarea = document.getElementById(`codeEditor-${questionId}`);
        const languageSelect = document.getElementById(`language-select-${questionId}`);
        const customInput = document.getElementById(`custom-input-${questionId}`);
        const resultsSection = document.getElementById(`results-${questionId}`);
        const resultOutput = document.getElementById(`result-output-${questionId}`);
        
        const code = codeTextarea.value;
        const languageId = languageSelect.value;
        const stdin = customInput.value;
        
        // Show loading message
        resultOutput.innerHTML = '<div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Running your code with custom input...</div>';
        resultsSection.style.display = 'block';
        
        try {
            // Create submission
            const token = await createSubmission(languageId, code, stdin);
            
            // Poll for result
            const result = await pollSubmissionResult(token);
            
            // Format and display result
            const formattedResult = formatOutput(result);
            
            let outputHtml = `<h4 class="section-title"><i class="fas fa-keyboard"></i> Custom Test Result:</h4>
                <pre class="execution-output">${escapeHtml(formattedResult.output)}</pre>
                <div class="execution-details">
                    <p><i class="fas fa-clock"></i> Execution Time: ${formattedResult.executionTime}s</p>
                    <p><i class="fas fa-memory"></i> Memory Used: ${Math.round(formattedResult.memory / 1000)}KB</p>
                </div>`;
            
            resultOutput.innerHTML = outputHtml;
        } catch (error) {
            resultOutput.innerHTML = `<p class="error"><i class="fas fa-exclamation-circle"></i> Error: ${error.message}</p>`;
        }
    }

    // Function to run all test cases
    async function runAllTests(questionId) {
        const codeTextarea = document.getElementById(`codeEditor-${questionId}`);
        const languageSelect = document.getElementById(`language-select-${questionId}`);
        const resultsSection = document.getElementById(`results-${questionId}`);
        const resultOutput = document.getElementById(`result-output-${questionId}`);
        const testResultsSection = document.getElementById(`test-results-${questionId}`);
        const testResultsBody = document.getElementById(`test-results-body-${questionId}`);
        if (!codeTextarea || !languageSelect) {
        console.error('Code editor or language selector not found');
        return;
    }
        const code = codeTextarea.value;
        const languageId = languageSelect.value;
        
        // Get the appropriate question data
        const examData = JSON.parse(localStorage.getItem('currentExam'));
        let question;
        
        if (examData.questionType === "coding") {
            const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
            question = codingQuestions.find(q => q._id == questionId);
        } else if (examData.questionType === "mcq&coding") {
            const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
            question = codingQuestions.find(q => q._id == questionId);
        }
        
        // Check if question has test cases
        if (!question || !question.testCases || question.testCases.length === 0) {
            resultOutput.innerHTML = '<p class="error"><i class="fas fa-exclamation-circle"></i> No test cases available for this question.</p>';
            return;
        }
        
        // Show loading message
        resultOutput.innerHTML = '<div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Running all test cases...</div>';
        resultsSection.style.display = 'block';
        testResultsSection.style.display = 'block';
        testResultsBody.innerHTML = '';
        
        let allTestsPassed = true;
        let totalTime = 0;
        let maxMemory = 0;
        
        // Run all test cases
         for (let i = 0; i < question.testCases.length; i++) {
        const testCase = question.testCases[i];
        
        try {
            // Create row with loading state
            const row = document.createElement('tr');
            row.id = `test-row-${questionId}-${i}`;
            row.innerHTML = `
                <td>Test Case ${i + 1}${testCase.isPublic ? ' (Public)' : ' (Hidden)'}</td>
                <td colspan="4"><i class="fas fa-spinner fa-spin"></i> Running...</td>
            `;
            testResultsBody.appendChild(row);
            
            // Create submission for this test case
            const token = await createSubmission(languageId, code, testCase.input);
            
            // Poll for result
            const result = await pollSubmissionResult(token);
            
            // Format result
            const formattedResult = formatOutput(result);
            
            // Check if output matches expected output
            const isCorrect = compareOutputs(testCase.expectedOutput, formattedResult.output);
            
            // Update aggregate statistics
            totalTime += parseFloat(formattedResult.executionTime || 0);
            maxMemory = Math.max(maxMemory, formattedResult.memory || 0);
            
            // If any test fails, mark all tests as failed
            if (!isCorrect) {
                allTestsPassed = false;
            }
            
            // Update the row with results
            row.innerHTML = `
                <td>Test Case ${i + 1}${testCase.isPublic ? ' (Public)' : ' (Hidden)'}</td>
                <td class="${isCorrect ? 'result-pass' : 'result-fail'}">
                    <i class="fas fa-${isCorrect ? 'check' : 'times'}-circle"></i> 
                    ${isCorrect ? 'PASS' : 'FAIL'}
                </td>
                <td>${formattedResult.executionTime}s</td>
                <td>${Math.round(formattedResult.memory / 1000)}KB</td>
                <td><span class="test-details-link" data-test-id="${questionId}-${i}">View Details</span></td>
            `;
            
            // Create hidden details div
            const detailsDiv = document.createElement('div');
            detailsDiv.id = `test-details-${questionId}-${i}`;
            detailsDiv.style.display = 'none';
            detailsDiv.className = 'test-case-details-container';
            
            detailsDiv.innerHTML = `
                <h4>Test Case ${i + 1} Details</h4>
                <div class="test-case-input">
                    <h5>Input:</h5>
                    <pre>${escapeHtml(testCase.input)}</pre>
                </div>
                <div class="test-case-output">
                    <h5>Expected Output:</h5>
                    <pre>${escapeHtml(testCase.expectedOutput)}</pre>
                </div>
                <div class="test-case-actual">
                    <h5>Your Output:</h5>
                    <pre>${escapeHtml(formattedResult.output)}</pre>
                </div>
            `;
            
            // If test failed, add diff view
            if (!isCorrect) {
                detailsDiv.appendChild(displayDiff(testCase.expectedOutput, formattedResult.output));
            }
            
            testResultsSection.appendChild(detailsDiv);
            
        } catch (error) {
            console.error('Error running test case:', error);
            allTestsPassed = false;
            
            // Update row with error
            const row = document.getElementById(`test-row-${questionId}-${i}`) || document.createElement('tr');
            row.innerHTML = `
                <td>Test Case ${i + 1}${testCase.isPublic ? ' (Public)' : ' (Hidden)'}</td>
                <td class="result-fail"><i class="fas fa-times-circle"></i> ERROR</td>
                <td>-</td>
                <td>-</td>
                <td>${error.message}</td>
            `;
            
            if (!row.parentNode) {
                testResultsBody.appendChild(row);
            }
        }
    }
    
    // Update overall result
    resultOutput.innerHTML = `
        <div class="result-summary">
            <h4><i class="fas fa-clipboard-check"></i> Overall Result:</h4>
            <p class="${allTestsPassed ? 'result-pass' : 'result-fail'}">
                <i class="fas fa-${allTestsPassed ? 'check' : 'times'}-circle"></i> 
                ${allTestsPassed ? 'All tests passed!' : 'Some tests failed!'}
            </p>
            <div class="execution-details">
                <p><i class="fas fa-clock"></i> Total Execution Time: ${totalTime.toFixed(3)}s</p>
                <p><i class="fas fa-memory"></i> Max Memory Used: ${Math.round(maxMemory / 1000)}KB</p>
            </div>
        </div>
    `;
        
        // Add event listeners to the "View Details" links
   document.querySelectorAll('.test-details-link').forEach(link => {
        link.addEventListener('click', function() {
            const testId = this.getAttribute('data-test-id');
            const detailsDiv = document.getElementById(`test-details-${testId}`);
            
            // Toggle display
            if (detailsDiv) {
                detailsDiv.style.display = detailsDiv.style.display === 'none' ? 'block' : 'none';
            }
        });
    });
    }

    // Add these styles for the modal and messages
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        /* Modal Styles */
        .modal-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .modal-content {
            background-color: white;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 500px;
            z-index: 1001;
            box-shadow: var(--shadow-lg);
            animation: modalFadeIn 0.3s;
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .modal-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
        }
        
        .modal-close {
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--secondary);
        }
        
        .modal-body {
            padding: 1.5rem;
        }
        
        .modal-footer {
            padding: 1rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }
        
        .modal-body .warning {
            color: var(--danger);
            background-color: #fee2e2;
            padding: 0.75rem;
            border-radius: 0.25rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* Message Styles */
        .message-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            max-width: 300px;
            z-index: 1000;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            transform: translateX(110%);
            transition: transform 0.3s ease;
        }
        
        .message-container.show {
            transform: translateX(0);
        }
        
        .message-content {
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .success-message .message-content {
            background-color: #ecfdf5;
            color: #064e3b;
            border-left: 4px solid #10b981;
        }
        
        .error-message .message-content {
            background-color: #fef2f2;
            color: #7f1d1d;
            border-left: 4px solid #ef4444;
        }
        
        /* Loading Spinner */
        .loading-spinner {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--primary);
            margin: 1rem 0;
        }
        
        /* Dark Theme Styles */
        body.dark-theme {
            background-color: #1e1e2d;
            color: #e5e7eb;
        }
        
        body.dark-theme .header,
        body.dark-theme .question-panel,
        body.dark-theme .sidebar-card {
            background-color: #252636;
            color: #e5e7eb;
        }
        
        body.dark-theme .nav-button {
            background-color: #2d2d3f;
            color: #e5e7eb;
            border-color: #374151;
        }
        
        body.dark-theme .nav-button:hover {
            background-color: #374151;
        }
        
        body.dark-theme pre {
            background-color: #1a1a2e;
            border-color: #374151;
            color: #e5e7eb;
        }
        
        body.dark-theme .mcq-option {
            background-color: #2d2d3f;
            border-color: #374151;
        }
        
        body.dark-theme .mcq-option:hover {
            background-color: #374151;
        }
        
        body.dark-theme .mcq-option.selected {
            background-color: #3b82f6;
            border-color: #2563eb;
            color: white;
        }
        
        body.dark-theme .btn-secondary {
            background-color: #374151;
            color: #e5e7eb;
            border-color: #4b5563;
        }
        
        body.dark-theme .btn-secondary:hover {
            background-color: #4b5563;
        }
        
        body.dark-theme .code-textarea {
            background-color: #1e1e1e;
            color: #e5e7eb;
            border-color: #374151;
        }
        
        body.dark-theme .test-results-table th,
        body.dark-theme .test-results-table td {
            border-color: #374151;
        }
        
        body.dark-theme .test-results-table th {
            background-color: #2d2d3f;
        }
        
        body.dark-theme .diff-expected {
            background-color: #064e3b;
            border-color: #10b981;
        }
        
        body.dark-theme .diff-actual {
            background-color: #7f1d1d;
            border-color: #ef4444;
        }
        
        body.dark-theme .dark-mode-toggle {
            color: #e5e7eb;
        }
        
        body.dark-theme .dark-mode-toggle:hover {
            background-color: #374151;
        }
        
        body.dark-theme .timer-display {
            background-color: #2d2d3f;
            color: #e5e7eb;
        }
        
        body.dark-theme .modal-content {
            background-color: #252636;
            color: #e5e7eb;
        }
        
        body.dark-theme .modal-header,
        body.dark-theme .modal-footer {
            border-color: #374151;
        }
    `;
    document.head.appendChild(styleElement);
    </script>
</body>
</html>
